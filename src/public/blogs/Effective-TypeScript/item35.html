<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><meta name="keywords" content="TypeScript,zhangxuekang,zhangxk"><link rel="shortcut icon" href="https://zhangxuekang.github.io/src/zhangxk.ico" type="image/x-icon"><title>zhangxk-Effective TypeScript Item 35</title><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.2.0/styles/default.min.css"><style>a,abbr,acronym,address,applet,article,aside,audio,b,big,blockquote,body,canvas,caption,center,cite,code,dd,del,details,dfn,div,dl,dt,em,embed,fieldset,figcaption,figure,footer,form,h1,h2,h3,h4,h5,h6,header,hgroup,html,i,iframe,img,ins,kbd,label,legend,li,mark,menu,nav,object,ol,output,p,pre,q,ruby,s,samp,section,small,span,strike,strong,sub,summary,sup,table,tbody,td,tfoot,th,thead,time,tr,tt,u,ul,var,video{margin:0;padding:0;border:0;font:inherit;vertical-align:baseline}article,aside,details,figcaption,figure,footer,header,hgroup,menu,nav,section{display:block}ol,ul{list-style:none}table{border-collapse:collapse;border-spacing:0}body{box-sizing:border-box;color:#373737;background:#212121;font-size:16px;font-family:"Myriad Pro",Calibri,Helvetica,Arial,sans-serif;line-height:1.5;-webkit-font-smoothing:antialiased}h1,h2,h3,h4,h5,h6{margin:10px 0;font-weight:700;color:#222;font-family:"Lucida Grande",Calibri,Helvetica,Arial,sans-serif;letter-spacing:-1px}h1{font-size:36px;font-weight:700}h2{margin-bottom:20px;font-size:32px;border-bottom:1px dashed #dadada}h3{font-size:24px}h4{font-size:21px}h5{font-size:18px}h6{font-size:16px}p{margin:10px 0 15px 0}footer p{color:#f2f2f2}a{text-decoration:none;color:#0f79d0;text-shadow:none;transition:color .5s ease;transition:text-shadow .5s ease;-webkit-transition:color .5s ease;-webkit-transition:text-shadow .5s ease;-moz-transition:color .5s ease;-moz-transition:text-shadow .5s ease;-o-transition:color .5s ease;-o-transition:text-shadow .5s ease;-ms-transition:color .5s ease;-ms-transition:text-shadow .5s ease}a:focus,a:hover{text-decoration:underline}footer a{color:#f2f2f2;text-decoration:underline}cite,em{font-style:italic}strong{font-weight:700}img{position:relative;margin:0 auto;max-width:739px;padding:5px;margin:10px 0 10px 0;border:1px solid #ebebeb;box-shadow:0 0 5px #ebebeb;-webkit-box-shadow:0 0 5px #ebebeb;-moz-box-shadow:0 0 5px #ebebeb;-o-box-shadow:0 0 5px #ebebeb;-ms-box-shadow:0 0 5px #ebebeb}p img{display:inline;margin:0;padding:0;vertical-align:middle;text-align:center;border:none}code,pre{color:#222;font-family:Monaco,"Bitstream Vera Sans Mono","Lucida Console",Terminal,monospace;font-size:.875em;border-radius:2px;-moz-border-radius:2px;-webkit-border-radius:2px}pre{padding:10px;box-shadow:0 0 10px rgba(0,0,0,.1);overflow:auto}code{padding:3px;margin:0 3px;box-shadow:0 0 10px rgba(0,0,0,.1)}pre code{display:block;box-shadow:none}blockquote{color:#666;margin-bottom:20px;padding:0 0 0 20px;border-left:3px solid #bbb}dl,ol,ul{margin-bottom:15px}ul{list-style-position:inside;list-style:disc;padding-left:20px}ol{list-style-position:inside;list-style:decimal;padding-left:20px}dl dt{font-weight:700}dl dd{padding-left:20px;font-style:italic}dl p{padding-left:20px;font-style:italic}hr{height:1px;margin-bottom:5px;border:none;background:url(../images/bg_hr.png) repeat-x center}table{border:1px solid #373737;margin-bottom:20px;margin-top:10px;text-align:left}th{font-family:"Lucida Grande","Helvetica Neue",Helvetica,Arial,sans-serif;padding:10px;background:#373737;color:#fff}td{padding:10px;border:1px solid #373737}form{background:#f2f2f2;padding:20px}kbd{background-color:#fafbfc;border:1px solid #c6cbd1;border-bottom-color:#959da5;border-radius:3px;box-shadow:inset 0 -1px 0 #959da5;color:#444d56;display:inline-block;font-size:11px;line-height:11px;padding:3px 5px;vertical-align:middle}.outer{width:100%}.inner{position:relative;max-width:640px;padding:20px 10px;margin:0 auto}#header_wrap{background:#212121;background:-moz-linear-gradient(top,#373737,#212121);background:-webkit-linear-gradient(top,#373737,#212121);background:-ms-linear-gradient(top,#373737,#212121);background:-o-linear-gradient(top,#373737,#212121);background:linear-gradient(to top,#373737,#212121)}#header_wrap .inner{padding:50px 10px 30px 10px}#project_title{margin:0;color:#fff;font-size:42px;font-weight:700;text-shadow:#111 0 0 10px}#project_tagline{color:#222;font-weight:300;background:0 0;text-shadow:#111 0 0 10px;border-bottom:none}#project_tagline span{display:inline-block;height:33px;font-size:13px;line-height:33px;overflow:hidden;margin-bottom:10px;margin-right:10px;padding:0 12px;border-radius:100px;background:rgba(242,242,242,.5)}#project_time{color:#fff;text-shadow:#111 0 0 10px}#main_content_wrap{background:#f2f2f2;border-top:1px solid #111;border-bottom:1px solid #111}#main_content{padding-top:40px}#footer_wrap{background:#212121}@media screen and (max-width:992px){img{max-width:100%}}@media screen and (max-width:480px){body{font-size:14px}#downloads{display:none}.inner{min-width:320px;max-width:480px}#project_title{font-size:32px}h1{font-size:28px}h2{font-size:24px}h3{font-size:21px}h4{font-size:18px}h5{font-size:14px}h6{font-size:12px}code,pre{font-size:11px}}@media screen and (max-width:320px){body{font-size:14px}#downloads{display:none}.inner{min-width:240px;max-width:320px}#project_title{font-size:28px}h1{font-size:24px}h2{font-size:21px}h3{font-size:18px}h4{font-size:16px}h5{font-size:14px}h6{font-size:12px}code,pre{min-width:240px;max-width:320px;font-size:11px}}#header_wrap{width:100%;background-size:cover;background-image:url(https://source.unsplash.com/1200x180/?nature,water)}pre{white-space:pre;word-wrap:normal;background:#282936}pre code{color:#e9e9f4;background:#262822}.cnblogs-markdown .hljs{display:block;overflow:auto;padding:1.3em 2em!important;font-size:16px!important;background:#272822!important;color:#fff;max-height:700px}.hljs,.hljs-subst,.hljs-tag{color:#f8f8f2}.hljs-emphasis,.hljs-strong{color:#a8a8a2}.hljs-bullet,.hljs-link,.hljs-literal,.hljs-number,.hljs-quote,.hljs-regexp{color:#ae81ff}.hljs-code,.hljs-section,.hljs-selector-class,.hljs-title{color:#a6e22e}.hljs-strong{font-weight:700}.hljs-emphasis{font-style:italic}.hljs-attr,.hljs-keyword,.hljs-name,.hljs-selector-tag{color:#f92672}.hljs-attribute,.hljs-symbol{color:#66d9ef}.hljs-class .hljs-title,.hljs-params{color:#f8f8f2}.hljs-addition,.hljs-built_in,.hljs-builtin-name,.hljs-selector-attr,.hljs-selector-id,.hljs-selector-pseudo,.hljs-string,.hljs-template-variable,.hljs-type,.hljs-variable{color:#e6db74}.hljs-comment,.hljs-deletion,.hljs-meta{color:#75715e}p>code{color:#c7254e;border:none!important;font-size:1em!important;background-color:#f9f2f4!important;font-weight:500;font-family:Monaco,"Bitstream Vera Sans Mono","Lucida Console",Terminal!important}</style></head><body><div id="header_wrap" class="outer"><header class="inner"><h1 id="project_title">Effective TypeScript Item 35</h1><p id="project_tagline"><span>TypeScript</span></p><p id="project_time">发布于 2021</p></header></div><div id="main_content_wrap" class="outer"><section id="main_content" class="inner"><ul><li><a href="#%E4%B8%8D%E8%A6%81%E6%A0%B9%E6%8D%AE%E6%95%B0%E6%8D%AE%E8%87%AA%E5%B7%B1%E5%86%99-types%E8%80%8C%E6%98%AF%E4%BD%BF%E7%94%A8%E5%AE%98%E6%96%B9-types">不要根据数据自己写 Types，而是使用官方 Types</a></li><li><a href="#%E8%87%AA%E5%8A%A8%E7%94%9F%E6%88%90%E7%B2%BE%E7%A1%AE%E7%9A%84-types">自动生成精确的 Types</a></li><li><a href="#%E6%B2%A1%E6%9C%89%E5%AE%98%E6%96%B9%E7%9A%84%E5%AE%9A%E4%B9%89%E5%92%8C-graphql-schema">没有官方的定义和 GraphQL schema？</a></li></ul><h2 id="不要根据数据自己写-types，而是使用官方-types">不要根据数据自己写 Types，而是使用官方 Types</h2><p>TypeScript 的类型对编程的好处不用多说了。在一些情况下，数据来源可能是 <code>file formats</code>, <code>APIs</code>, or <code>specs</code>，如果你直接从数据上“抽象”出 Types，可能会漏掉某些边界情况。</p><p>有一个 <code>GeoJSON</code> 的例子：</p><pre><code class="language-ts"><span class="hljs-keyword">function</span> <span class="hljs-title function_">calculateBoundingBox</span>(<span class="hljs-params">f: GeoJSONFeature</span>): <span class="hljs-title class_">BoundingBox</span> | <span class="hljs-literal">null</span> {
  <span class="hljs-keyword">let</span> <span class="hljs-attr">box</span>: <span class="hljs-title class_">BoundingBox</span> | <span class="hljs-literal">null</span> = <span class="hljs-literal">null</span>;

  <span class="hljs-keyword">const</span> <span class="hljs-title function_">helper</span> = (<span class="hljs-params">coords: <span class="hljs-built_in">any</span>[]</span>) =&gt; {
    <span class="hljs-comment">// ...</span>
  };

  <span class="hljs-keyword">const</span> { geometry } = f;
  <span class="hljs-keyword">if</span> (geometry) {
    <span class="hljs-title function_">helper</span>(geometry.<span class="hljs-property">coordinates</span>);
  }

  <span class="hljs-keyword">return</span> box;
}
</code></pre><p>函数入参 <code>GeoJSONFeature</code> 没有被精确的定义，只是根据一些数据实例抽象出的定义（假设你是这么做的）。</p><p>最好使用 <code>GeoJSON</code> 官方的标准定义。</p><blockquote><p>GeoJSON is also known as RFC 7946. The very readable spec is at <a href="http://geojson.org">http://geojson.org</a>.</p></blockquote><pre><code class="language-shell"><span class="hljs-meta">$ </span><span class="language-bash">npm install --save-dev @types/geojson</span>
+ @types/geojson@7946.0.7
</code></pre><p>现在使用官方定义的 Types 替换自己写的类型，TypeScript 马上就报错了：</p><pre><code class="language-ts"><span class="hljs-keyword">import</span> { <span class="hljs-title class_">Feature</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;geojson&quot;</span>;

<span class="hljs-keyword">function</span> <span class="hljs-title function_">calculateBoundingBox</span>(<span class="hljs-params">f: Feature</span>): <span class="hljs-title class_">BoundingBox</span> | <span class="hljs-literal">null</span> {
  <span class="hljs-keyword">let</span> <span class="hljs-attr">box</span>: <span class="hljs-title class_">BoundingBox</span> | <span class="hljs-literal">null</span> = <span class="hljs-literal">null</span>;

  <span class="hljs-keyword">const</span> <span class="hljs-title function_">helper</span> = (<span class="hljs-params">coords: <span class="hljs-built_in">any</span>[]</span>) =&gt; {
    <span class="hljs-comment">// ...</span>
  };

  <span class="hljs-keyword">const</span> { geometry } = f;
  <span class="hljs-keyword">if</span> (geometry) {
    <span class="hljs-title function_">helper</span>(geometry.<span class="hljs-property">coordinates</span>);
    <span class="hljs-comment">// ~~~~~~~~~~~</span>
    <span class="hljs-comment">// Property &#x27;coordinates&#x27; does not exist on type &#x27;Geometry&#x27;</span>
    <span class="hljs-comment">//   Property &#x27;coordinates&#x27; does not exist on type</span>
    <span class="hljs-comment">//   &#x27;GeometryCollection&#x27;</span>
  }

  <span class="hljs-keyword">return</span> box;
}
</code></pre><p>问题是因为代码假设 <code>geometry</code> 一定会有 <code>coordinates</code> 属性，对大多数情况来说是这样的（for many geometries, including points, lines, and polygons），但是 <code>GeometryCollection</code> 就没有 <code>coordinates</code> 属性。如果函数入参正好是 <code>GeometryCollection</code>，就会出现 bug。</p><p>可以这样简单处理：</p><pre><code class="language-ts"><span class="hljs-keyword">const</span> { geometry } = f;
<span class="hljs-keyword">if</span> (geometry) {
  <span class="hljs-keyword">if</span> (geometry.<span class="hljs-property">type</span> === <span class="hljs-string">&quot;GeometryCollection&quot;</span>) {
    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&quot;GeometryCollections are not supported.&quot;</span>);
  }
  <span class="hljs-title function_">helper</span>(geometry.<span class="hljs-property">coordinates</span>); <span class="hljs-comment">// OK</span>
}
</code></pre><p>更好的处理是让你的函数能真正支持所有的 geometry 类型：</p><pre><code class="language-ts"><span class="hljs-keyword">const</span> <span class="hljs-title function_">geometryHelper</span> = (<span class="hljs-params">g: Geometry</span>) =&gt; {
  <span class="hljs-keyword">if</span> (geometry.<span class="hljs-property">type</span> === <span class="hljs-string">&quot;GeometryCollection&quot;</span>) {
    geometry.<span class="hljs-property">geometries</span>.<span class="hljs-title function_">forEach</span>(geometryHelper);
  } <span class="hljs-keyword">else</span> {
    <span class="hljs-title function_">helper</span>(geometry.<span class="hljs-property">coordinates</span>); <span class="hljs-comment">// OK</span>
  }
};

<span class="hljs-keyword">const</span> { geometry } = f;
<span class="hljs-keyword">if</span> (geometry) {
  <span class="hljs-title function_">geometryHelper</span>(geometry);
}
</code></pre><h2 id="自动生成精确的-types">自动生成精确的 Types</h2><p>GraphQL 是一个用于 API 的查询语言，是一个使用基于类型系统来执行查询的服务端运行时（类型系统由你的数据定义）。</p><p>使用 GraphQL 写一个获取信息的接口可能像是这样的：</p><pre><code>query {
  repository(owner: &quot;Microsoft&quot;, name: &quot;TypeScript&quot;) {
    createdAt
    description
  }
}
</code></pre><p>结果是：</p><pre><code class="language-json"><span class="hljs-punctuation">{</span>
  <span class="hljs-attr">&quot;data&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">{</span>
    <span class="hljs-attr">&quot;repository&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">{</span>
      <span class="hljs-attr">&quot;createdAt&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;2014-06-17T15:28:39Z&quot;</span><span class="hljs-punctuation">,</span>
      <span class="hljs-attr">&quot;description&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;TypeScript is a superset of JavaScript that compiles to JavaScript.&quot;</span>
    <span class="hljs-punctuation">}</span>
  <span class="hljs-punctuation">}</span>
<span class="hljs-punctuation">}</span>
</code></pre><p>TypeScript 的 Types 可以和 GraphQL 的模板精确的对应起来。</p><p>下面是一个获取公共许可的 GraphQL 接口定义：</p><pre><code>query getLicense($owner:String!, $name:String!){
  repository(owner:$owner, name:$name) {
    description
    licenseInfo {
      spdxId
      name
    }
  }
}
</code></pre><p>这些信息已经足够构建出 TypeScript 的 Types 了。有很多工具可以帮助你根据 GraphQL 生成 TypeScript Types。以工具 <code>Apollo</code> 为例：</p><pre><code class="language-shell"><span class="hljs-meta">$ </span><span class="language-bash">apollo client:codegen \
    --endpoint https://api.github.com/graphql \
    --includes license.graphql \
    --target typescript</span>
Loading Apollo Project
Generating query files with &#x27;typescript&#x27; target - wrote 2 files
</code></pre><p>产出是这样的：</p><pre><code class="language-ts"><span class="hljs-keyword">export</span> <span class="hljs-keyword">interface</span> getLicense_repository_licenseInfo {
  <span class="hljs-attr">__typename</span>: <span class="hljs-string">&quot;License&quot;</span>;
  <span class="hljs-comment">/** Short identifier specified by &lt;https://spdx.org/licenses&gt; */</span>
  <span class="hljs-attr">spdxId</span>: <span class="hljs-built_in">string</span> | <span class="hljs-literal">null</span>;
  <span class="hljs-comment">/** The license full name specified by &lt;https://spdx.org/licenses&gt; */</span>
  <span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span>;
}

<span class="hljs-keyword">export</span> <span class="hljs-keyword">interface</span> getLicense_repository {
  <span class="hljs-attr">__typename</span>: <span class="hljs-string">&quot;Repository&quot;</span>;
  <span class="hljs-comment">/** The description of the repository. */</span>
  <span class="hljs-attr">description</span>: <span class="hljs-built_in">string</span> | <span class="hljs-literal">null</span>;
  <span class="hljs-comment">/** The license associated with the repository */</span>
  <span class="hljs-attr">licenseInfo</span>: getLicense_repository_licenseInfo | <span class="hljs-literal">null</span>;
}

<span class="hljs-keyword">export</span> <span class="hljs-keyword">interface</span> getLicense {
  <span class="hljs-comment">/** Lookup a given repository by the owner and repository name. */</span>
  <span class="hljs-attr">repository</span>: getLicense_repository | <span class="hljs-literal">null</span>;
}

<span class="hljs-keyword">export</span> <span class="hljs-keyword">interface</span> getLicenseVariables {
  <span class="hljs-attr">owner</span>: <span class="hljs-built_in">string</span>;
  <span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span>;
}
</code></pre><ul><li>同时生成了请求的入参 <code>interface</code> 和请求结果 <code>interface</code></li><li>精确指出了哪些是必须有的，哪些是可以有的属性（Nullability）</li><li>自动添加注解</li></ul><p>如果查询改变，Types 自动改变，如果 GraphQL 模板改变，Types 也会自动改变。</p><h2 id="没有官方的定义和-graphql-schema？">没有官方的定义和 GraphQL schema？</h2><p>那你只能从 data 中“抽象”出类型了。有一些工具，例如 <code>quicktype</code>(<a href="https://quicktype.io/">https://quicktype.io/</a>) 可以帮助你做这件事，但是要注意，无论是自己写还是工具帮助，从 data 中生成类型总是会可能漏掉一些边界情况。</p><p>即使你没有注意到，其实你已经开始使用官方定义的接口了，例如 <code>browser DOM API</code>。</p></section></div><div id="footer_wrap" class="outer"><footer class="inner"><p class="update-time">更新于 2021-09-27</p><p class="copyright">zhangxk-notes maintained by <a href="https://github.com/zhangxuekang">zhangxuekang</a></p></footer></div></body></html>
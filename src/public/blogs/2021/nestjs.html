<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <link
      rel="stylesheet"
      href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.2.0/styles/default.min.css"
    />
    <link rel="stylesheet" href="src/index.css" />
    <title>${title}</title>
    <style>
      html,
      body,
      ul,
      li,
      ol,
      dl,
      dd,
      dt,
      p,
      h1,
      h2,
      h3,
      h4,
      h5,
      h6,
      form,
      fieldset,
      legend,
      img {
        margin: 0;
        padding: 0;
      }

      body {
        width: 60%;
        margin-left: 20%;
      }
    </style>
  </head>
  <body>
    <h1 id="nestjs-笔记">NestJS 笔记</h1>
<p><img src="../assets/nestjs_cat.png" alt="NestJS"></p>
<p>Nest 是一个用于构建高效，可扩展的 Node.js 服务器端应用程序的框架。它使用渐进式 JavaScript，内置并完全支持 TypeScript（但仍然允许开发人员使用纯 JavaScript 编写代码）并结合了 OOP（面向对象编程），FP（函数式编程）和 FRP（函数式响应编程）的元素。</p>
<p>在底层，Nest 使用强大的 HTTP Server 框架，如 Express（默认）和 Fastify。Nest 在这些框架之上提供了一定程度的抽象，同时也将其 API 直接暴露给开发人员。这样可以轻松使用每个平台的无数第三方模块。</p>
<p>Nest 提供了一个开箱即用的应用程序架构，允许开发人员和团队创建高度可测试，可扩展，松散耦合且易于维护的应用程序。</p>
<h2 id="安装">安装</h2>
<pre><code class="language-shell"><span class="hljs-meta">$ </span><span class="language-bash">npm i -g @nestjs/cli</span>
<span class="hljs-meta">$ </span><span class="language-bash">nest new project-name</span>
</code></pre>
<h2 id="运行应用程序">运行应用程序</h2>
<table>
<thead>
<tr>
<th>文件</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>app.controller.ts</td>
<td>带有单个路由的基本控制器示例。</td>
</tr>
<tr>
<td>app.module.ts</td>
<td>应用程序的根模块。</td>
</tr>
<tr>
<td>main.ts</td>
<td>应用程序入口文件。它使用 NestFactory 用来创建 Nest 应用实例。</td>
</tr>
</tbody></table>
<p>main.ts 包含一个异步函数，它负责引导我们的应用程序：</p>
<pre><code class="language-ts"><span class="hljs-keyword">import</span> { <span class="hljs-title class_">NestFactory</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;@nestjs/core&quot;</span>;
<span class="hljs-keyword">import</span> { <span class="hljs-title class_">ApplicationModule</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./app.module&quot;</span>;

<span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">bootstrap</span>(<span class="hljs-params"></span>) {
  <span class="hljs-keyword">const</span> app = <span class="hljs-keyword">await</span> <span class="hljs-title class_">NestFactory</span>.<span class="hljs-title function_">create</span>(<span class="hljs-title class_">ApplicationModule</span>);
  <span class="hljs-keyword">await</span> app.<span class="hljs-title function_">listen</span>(<span class="hljs-number">3000</span>);
}
<span class="hljs-title function_">bootstrap</span>();
</code></pre>
<p>启动应用程序</p>
<pre><code class="language-shell"><span class="hljs-meta">$ </span><span class="language-bash">npm run start</span>
</code></pre>
<p>此命令在 src 目录中的 main.ts 文件中定义的端口上启动 HTTP 服务器。在应用程序运行时, 打开浏览器并访问 <a href="http://localhost:3000/%E3%80%82">http://localhost:3000/。</a></p>
<h2 id="模块">模块</h2>
<p>模块是具有 @Module() 装饰器的类。 @Module() 装饰器提供了元数据，Nest 用它来组织应用程序结构。</p>
<p>每个 Nest 应用程序至少有一个模块，即根模块。根模块是 Nest 开始安排应用程序树的地方。事实上，根模块可能是应用程序中唯一的模块，特别是当应用程序很小时，但是对于大型程序来说这是没有意义的。</p>
<p>这是 cli 创建的根模块代码:</p>
<pre><code class="language-ts"><span class="hljs-keyword">import</span> { <span class="hljs-title class_">Module</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;@nestjs/common&quot;</span>;
<span class="hljs-keyword">import</span> { <span class="hljs-title class_">AppController</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./app.controller&quot;</span>;
<span class="hljs-keyword">import</span> { <span class="hljs-title class_">AppService</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./app.service&quot;</span>;

<span class="hljs-meta">@Module</span>({
  <span class="hljs-attr">imports</span>: [],
  <span class="hljs-attr">controllers</span>: [<span class="hljs-title class_">AppController</span>],
  <span class="hljs-attr">providers</span>: [<span class="hljs-title class_">AppService</span>],
})
<span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AppModule</span> {}
</code></pre>
<table>
<thead>
<tr>
<th>属性</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>providers</td>
<td>由 Nest 注入器实例化的提供者，并且可以至少在整个模块中共享</td>
</tr>
<tr>
<td>controllers</td>
<td>必须创建的一组控制器</td>
</tr>
<tr>
<td>imports</td>
<td>导入模块的列表，这些模块导出了此模块中所需提供者</td>
</tr>
<tr>
<td>exports</td>
<td>由本模块提供并应在其他模块中可用的提供者的子集。</td>
</tr>
</tbody></table>
<h2 id="控制器">控制器</h2>
<p>控制器负责处理传入的 <strong>请求</strong> 和向客户端返回 <strong>响应</strong> 。</p>
<pre><code class="language-ts"><span class="hljs-keyword">import</span> { <span class="hljs-title class_">Controller</span>, <span class="hljs-title class_">Get</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;@nestjs/common&quot;</span>;
<span class="hljs-keyword">import</span> { <span class="hljs-title class_">AppService</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./app.service&quot;</span>;

<span class="hljs-meta">@Controller</span>()
<span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AppController</span> {
  <span class="hljs-title function_">constructor</span>(<span class="hljs-params"><span class="hljs-keyword">private</span> <span class="hljs-keyword">readonly</span> appService: AppService</span>) {}

  <span class="hljs-meta">@Get</span>()
  <span class="hljs-title function_">getHello</span>(): <span class="hljs-built_in">string</span> {
    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">appService</span>.<span class="hljs-title function_">getHello</span>();
  }
}
</code></pre>
<p>为了创建一个基本的控制器，我们必须使用装饰器。装饰器将类与所需的元数据关联，并使 Nest 能够创建路由映射（将请求绑定到相应的控制器）。</p>
<h2 id="提供者">提供者</h2>
<p>Providers 是 Nest 的一个基本概念。许多基本的 Nest 类可能被视为 provider - service, repository, factory, helper 等等。 他们都可以通过 constructor 注入依赖关系。 这意味着对象可以彼此创建各种关系，并且“连接”对象实例的功能在很大程度上可以委托给 Nest 运行时系统。 Provider 只是一个用 @Injectable() 装饰器注释的类。</p>
<p>初始项目里的最简单服务代码:</p>
<pre><code class="language-ts"><span class="hljs-keyword">import</span> { <span class="hljs-title class_">Injectable</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;@nestjs/common&quot;</span>;

<span class="hljs-meta">@Injectable</span>()
<span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AppService</span> {
  <span class="hljs-title function_">getHello</span>(): <span class="hljs-built_in">string</span> {
    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Hello World!&quot;</span>;
  }
}
</code></pre>
<p>这个服务只提供了一个 <code>getHello</code>, 用来返回 <code>&quot;Hello World!&quot;</code> 字符串。</p>
<p>该服务被依赖注入到上边的控制器里面，控制器注册在主模块里边。当服务起来后，访问 <code>http://localhost:3000/</code> 会看到 <code>&quot;Hello world!&quot;</code> 信息。</p>
<ul>
<li><a href="https://nestjs.com/">NestJS 官网</a></li>
<li><a href="https://docs.nestjs.cn/6/introduction">中文文档</a></li>
</ul>

  </body>
</html>

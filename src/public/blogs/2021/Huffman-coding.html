<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <link
      rel="stylesheet"
      href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.2.0/styles/default.min.css"
    />
    <link rel="stylesheet" href="src/index.css" />
    <title>${title}</title>
    <style>
      html,
      body,
      ul,
      li,
      ol,
      dl,
      dd,
      dt,
      p,
      h1,
      h2,
      h3,
      h4,
      h5,
      h6,
      form,
      fieldset,
      legend,
      img {
        margin: 0;
        padding: 0;
      }

      body {
        width: 60%;
        margin-left: 20%;
      }
    </style>
  </head>
  <body>
    <ul>
<li><a href="#%E9%9C%8D%E5%A4%AB%E6%9B%BC%E7%BC%96%E7%A0%81huffman-coding%E7%AE%80%E4%BB%8B">霍夫曼编码(Huffman coding)简介</a></li>
<li><a href="#%E7%BC%96%E7%A0%81%E8%BF%87%E7%A8%8B">编码过程</a><ul>
<li><a href="#%E7%A4%BA%E4%BE%8B">示例</a><ul>
<li><a href="#%E5%85%88%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA%E9%9C%8D%E5%A4%AB%E6%9B%BC%E6%A0%91">先创建一个霍夫曼树。</a></li>
<li><a href="#%E8%BF%9B%E8%A1%8C%E7%BC%96%E7%A0%81">进行编码</a></li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="霍夫曼编码huffman-coding简介">霍夫曼编码(Huffman coding)简介</h2>
<p>霍夫曼编码（Huffman Coding），又译为哈夫曼编码、赫夫曼编码，是一种用于无损数据压缩的熵编码（权编码）算法。由美国计算机科学家大卫·霍夫曼（David Albert Huffman）在 1952 年发明。</p>
<p>特点：在计算机资料处理中，霍夫曼编码使用变长编码表对源符号（如文件中的一个字母）进行编码，其中变长编码表是通过一种评估来源符号出现概率的方法得到的，出现概率高的字母使用较短的编码，反之出现概率低的则使用较长的编码，这便使编码之后的字符串的平均长度、期望值降低，从而达到无损压缩数据的目的。</p>
<p>例如，在英文中，e 的出现概率最高，而 z 的出现概率则最低。当利用霍夫曼编码对一篇英文进行压缩时，e 极有可能用一个比特来表示，而 z 则可能花去 25 个比特（不是 26）。用普通的表示方法时，每个英文字母均占用一个字节，即 8 个比特。二者相比，e 使用了一般编码的 1/8 的长度，z 则使用了 3 倍多。倘若我们能实现对于英文中各个字母出现概率的较准确的估算，就可以大幅度提高无损压缩的比例。</p>
<p>霍夫曼树又称最优二叉树，是一种带权路径长度最短的二叉树。所谓树的带权路径长度，就是树中所有的叶结点的权值乘上其到根结点的路径长度（若根结点为 0 层，叶结点到根结点的路径长度为叶结点的层数）。树的路径长度是从树根到每一结点的路径长度之和，记为 WPL=（W1<em>L1+W2</em>L2+W3<em>L3+...+Wn</em>Ln），N 个权值 Wi（i=1,2,...n）构成一棵有 N 个叶结点的二叉树，相应的叶结点的路径长度为 Li（i=1,2,...n）。可以证明霍夫曼树的 WPL 是最小的。</p>
<h2 id="编码过程">编码过程</h2>
<p>霍夫曼树常处理符号编写工作。根据整组资料中符号出现的频率高低，决定如何给符号编码。如果符号出现的频率越高，则给符号的码越短，相反符号的号码越长。</p>
<h3 id="示例">示例</h3>
<p>假设我们要给一个英文单字&quot;F O R G E T&quot;进行霍夫曼编码，而每个英文字母出现的频率如下图。</p>
<p><img src="../assets/huffman_1.jpeg" alt="出现频率"></p>
<h4 id="先创建一个霍夫曼树。">先创建一个霍夫曼树。</h4>
<p><img src="../assets/huffman_2.gif" alt="创建过程"></p>
<ol>
<li>将每个英文字母依照出现频率由小排到大，最小在左。</li>
<li>每个字母都代表一个终端节点（叶节点），比较 F.O.R.G.E.T 六个字母中每个字母的出现频率，将最小的两个字母频率相加合成一个新的节点。发现 F 与 O 的频率最小，故相加 2+3=5。</li>
<li>比较 5.R.G.E.T，发现 R 与 G 的频率最小，故相加 4+4=8。</li>
<li>比较 5.8.E.T，发现 5 与 E 的频率最小，故相加 5+5=10。</li>
<li>比较 8.10.T，发现 8 与 T 的频率最小，故相加 8+7=15。</li>
<li>最后剩 10.15，没有可以比较的对象，相加 10+15=25。</li>
</ol>
<p>最后产生的树状图就是霍夫曼树。</p>
<h4 id="进行编码">进行编码</h4>
<p><img src="../assets/huffman_3.jpeg" alt="编码"></p>
<ol>
<li>给霍夫曼树的所有左链接&#39;0&#39;与右链接&#39;1&#39;。</li>
<li>从树根至树叶依序记录所有字母的编码。</li>
</ol>
<blockquote>
<p><a href="https://zh.wikipedia.org/wiki/%E9%9C%8D%E5%A4%AB%E6%9B%BC%E7%BC%96%E7%A0%81">https://zh.wikipedia.org/wiki/%E9%9C%8D%E5%A4%AB%E6%9B%BC%E7%BC%96%E7%A0%81</a></p>
<p><a href="https://juejin.cn/post/6844903778039103501">https://juejin.cn/post/6844903778039103501</a></p>
<p><a href="https://juejin.cn/post/6844904134835961870">https://juejin.cn/post/6844904134835961870</a></p>
</blockquote>

  </body>
</html>

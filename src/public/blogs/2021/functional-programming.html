<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <link
      rel="stylesheet"
      href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.2.0/styles/default.min.css"
    />
    <title>${title}</title>
  </head>
  <body>
    <h1 id="函数式编程">函数式编程</h1>
<p>什么是函数式编程？</p>
<p>维基百科定义：</p>
<blockquote>
<p>函数式编程[Functional Programming]是一种编程模型，他将计算机运算看做是数学中函数的计算，并且避免了状态以及变量的概念。</p>
</blockquote>
<p>函数式编程和过程式编程有什么区别？</p>
<p>举个栗子，现在有一个这样的表达式：</p>
<pre><code class="language-javascript">(<span class="hljs-number">1</span> + <span class="hljs-number">2</span>) * <span class="hljs-number">3</span> - <span class="hljs-number">4</span>;
</code></pre>
<p>过程式编程可能是这样实现的：</p>
<pre><code class="language-javascript"><span class="hljs-keyword">const</span> a = <span class="hljs-number">1</span> + <span class="hljs-number">2</span>;
<span class="hljs-keyword">const</span> b = a * <span class="hljs-number">3</span>;
<span class="hljs-keyword">const</span> c = b - <span class="hljs-number">4</span>;
</code></pre>
<p>使用函数式编程会将计算过程定义为不同的函数，依次调用函数：</p>
<pre><code class="language-javascript"><span class="hljs-keyword">const</span> result = <span class="hljs-title function_">subtract</span>(<span class="hljs-title function_">multiply</span>(<span class="hljs-title function_">add</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>), <span class="hljs-number">3</span>), <span class="hljs-number">4</span>);
</code></pre>
<p>除了调用函数，一点多余的代码都不需要写。这些函数甚至不用自己定义，各种函数库随你使用。</p>
<h3 id="函数式编程的特点">函数式编程的特点</h3>
<ol>
<li>函数是&quot;第一等公民&quot;<ul>
<li>所谓&quot;第一等公民&quot;（first class），指的是函数与其他数据类型一样，处于平等地位，可以赋值给其他变量，也可以作为参数，传入另一个函数，或者作为别的函数的返回值。javascript 中的函数天生就是一等公民。</li>
<li>举例来说 print 变量就是一个函数，可以作为另一个函数的参数</li>
</ul>
</li>
</ol>
<pre><code class="language-javascript"><span class="hljs-keyword">const</span> <span class="hljs-title function_">print</span> = (<span class="hljs-params">v</span>) =&gt; <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(v);
[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>].<span class="hljs-title function_">forEach</span>(print);
</code></pre>
<ul>
<li>理解函数是一等公民的本质，会让你删除很多无用的间接层代码。</li>
</ul>
<pre><code class="language-javascript"><span class="hljs-keyword">const</span> <span class="hljs-title function_">getServerStuff</span> = (<span class="hljs-params">callback</span>) =&gt; <span class="hljs-title function_">ajaxCall</span>(<span class="hljs-function">(<span class="hljs-params">json</span>) =&gt;</span> <span class="hljs-title function_">callback</span>(json));
<span class="hljs-comment">// 等价于</span>
<span class="hljs-keyword">const</span> getServerStuff = ajaxCall;

<span class="hljs-comment">// 逐步分析</span>
<span class="hljs-comment">// const fn = (json) =&gt; callback(json);</span>
<span class="hljs-comment">// fn(&#x27;abc&#x27;) -&gt; callback(&#x27;abc&#x27;)</span>
<span class="hljs-comment">// fn -&gt; callback</span>
<span class="hljs-comment">// 这行</span>
<span class="hljs-title function_">ajaxCall</span>(<span class="hljs-function">(<span class="hljs-params">json</span>) =&gt;</span> <span class="hljs-title function_">callback</span>(json));

<span class="hljs-comment">// 等价于这行</span>
<span class="hljs-title function_">ajaxCall</span>(callback);

<span class="hljs-comment">// 那么，重构下 getServerStuff</span>
<span class="hljs-keyword">const</span> <span class="hljs-title function_">getServerStuff</span> = (<span class="hljs-params">callback</span>) =&gt; <span class="hljs-title function_">ajaxCall</span>(callback);

<span class="hljs-comment">// ...就等于</span>
<span class="hljs-keyword">const</span> getServerStuff = ajaxCall;
</code></pre>
<ol>
<li>只用&quot;表达式&quot;，不用&quot;语句&quot;<ul>
<li>&quot;表达式&quot;（expression）是一个单纯的运算过程，总是有返回值；&quot;语句&quot;（statement）是执行某种操作，没有返回值。</li>
<li>函数式编程要求每一步都是单纯的运算，而且都有返回值。</li>
<li>函数式编程的动机是进行运算。</li>
</ul>
</li>
<li>没有&quot;副作用&quot;<ul>
<li>所谓&quot;副作用&quot;（side effect），指的是函数内部与外部互动（最典型的情况，就是修改全局变量的值），产生运算以外的其他结果。</li>
<li>函数式编程不考虑系统的读写（I/O）。</li>
<li>函数要保持独立，不得修改外部变量的值。</li>
</ul>
</li>
<li>不修改状态<ul>
<li>强调不修改外部变量</li>
</ul>
</li>
<li>引用透明<ul>
<li>引用透明（Referential transparency），指的是函数的运行不依赖于外部变量或&quot;状态&quot;，只依赖于输入的参数，任何时候只要参数相同，引用函数所得到的返回值总是相同的。</li>
</ul>
</li>
</ol>
<h4 id="this">this</h4>
<p>值得一提的是，函数式编程不建议在函数中使用<code>this</code>关键字，因为<code>this</code>的行为依赖函数运行的实际情况。而函数式编程要求无论何时，无论是谁调用这个函数，只要输入参数一样，必然能输出相同的结果。</p>
<h3 id="纯函数的好处">纯函数的好处</h3>
<p><strong><code>&quot;纯&quot;</code></strong> ：相同的输入，永远会得到相同的输出，而且没有任何可观察的副作用。</p>
<pre><code class="language-javascript"><span class="hljs-keyword">var</span> xs = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>];

<span class="hljs-comment">// 纯的</span>
xs.<span class="hljs-title function_">slice</span>(<span class="hljs-number">0</span>, <span class="hljs-number">3</span>);
<span class="hljs-comment">//=&gt; [1,2,3].</span>
xs.<span class="hljs-title function_">slice</span>(<span class="hljs-number">0</span>, <span class="hljs-number">3</span>);
<span class="hljs-comment">//=&gt; [1,2,3]</span>
xs.<span class="hljs-title function_">slice</span>(<span class="hljs-number">0</span>, <span class="hljs-number">3</span>);
<span class="hljs-comment">//=&gt; [1,2,3]</span>

<span class="hljs-comment">// 不纯的</span>
xs.<span class="hljs-title function_">splice</span>(<span class="hljs-number">0</span>, <span class="hljs-number">3</span>);
<span class="hljs-comment">//=&gt; [1,2,3]</span>
xs.<span class="hljs-title function_">splice</span>(<span class="hljs-number">0</span>, <span class="hljs-number">3</span>);
<span class="hljs-comment">//=&gt; [4,5]</span>
xs.<span class="hljs-title function_">splice</span>(<span class="hljs-number">0</span>, <span class="hljs-number">3</span>);
<span class="hljs-comment">//=&gt; []</span>
</code></pre>
<blockquote>
<p>副作用是在计算结果的过程中，系统状态的一种变化，或者与外部世界进行的可观察的交互。</p>
</blockquote>
<p>副作用可能包含，但不限于：</p>
<ul>
<li>更改文件系统</li>
<li>往数据库插入记录</li>
<li>发送一个 http 请求</li>
<li>可变数据</li>
<li>打印/log</li>
<li>获取用户输入</li>
<li>DOM 查询</li>
<li>访问系统状态</li>
</ul>
<p>一个系统不可能不产生副作用而单独运行，函数式编程要让副作用在可控的范围内发生。<br>(函数式编程的部分，更像是计算机系统中的 CPU 角色，负责底层逻辑的运算)</p>
<h4 id="追求纯的理由">追求“纯”的理由</h4>
<ul>
<li>可缓存性（Cacheable）<ul>
<li>因为纯函数对相同的输入总是产生相同的输入，所以完全可以缓存结果</li>
<li>缓存过的纯函数，相同参数运行过一次，再次运行时，直接从缓存中读取结果，省去了计算过程</li>
</ul>
</li>
</ul>
<pre><code class="language-javascript"><span class="hljs-keyword">const</span> memoize = <span class="hljs-keyword">function</span> (<span class="hljs-params">f</span>) {
  <span class="hljs-keyword">const</span> cache = {};
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) {
    <span class="hljs-keyword">var</span> arg_str = <span class="hljs-variable constant_">JSON</span>.<span class="hljs-title function_">stringify</span>(<span class="hljs-variable language_">arguments</span>);
    cache[arg_str] = cache[arg_str] || f.<span class="hljs-title function_">apply</span>(f, <span class="hljs-variable language_">arguments</span>);
    <span class="hljs-keyword">return</span> cache[arg_str];
  };
};
</code></pre>
<ul>
<li>可移植性／自文档化（Portable / Self-Documenting）<ul>
<li>纯函数是&quot;自给自足&quot;的， 纯函数的依赖很明确。 需要什么资源，就必须当做参数传进去。</li>
<li>纯函数可以毫无压力的移植到不同项目中使用。</li>
</ul>
</li>
</ul>
<pre><code class="language-javascript">    <span class="hljs-comment">// 不纯的，只能在当前Db数据库中使用</span>
    <span class="hljs-keyword">var</span> saveUser = <span class="hljs-keyword">function</span>(<span class="hljs-params">attrs</span>) {
       <span class="hljs-keyword">var</span> user = <span class="hljs-title class_">Db</span>.<span class="hljs-title function_">save</span>(attrs);
       ...
    ;
    <span class="hljs-comment">// 纯的， 函数可移植到任何数据库使用</span>
    <span class="hljs-keyword">var</span> saveUser = <span class="hljs-keyword">function</span>(<span class="hljs-params">attrs， Db</span>) {
       <span class="hljs-keyword">var</span> user = <span class="hljs-title class_">Db</span>.<span class="hljs-title function_">save</span>(attrs);
       ...
    ;
</code></pre>
<ul>
<li><p>可测试性（Testable）</p>
<ul>
<li>因为纯函数对每次相同输入都有相同的输入，并且纯函数的不依赖运行的环境因素，所以做单元测试的时候更加容易。</li>
</ul>
</li>
<li><p>合理性（Reasonable）</p>
<ul>
<li><p>引用透明</p>
<blockquote>
<p>如果一段代码可以替换成它执行所得的结果，而且是在不改变整个程序行为的前提下替换的，那么我们就说这段代码是引用透明的。</p>
</blockquote>
</li>
<li><p>纯函数保证了引用透明。</p>
</li>
<li><p>使用纯函数编写的程序代码，更容易分模块，更容易被理解分析</p>
</li>
</ul>
</li>
<li><p>并行代码</p>
<ul>
<li>纯函数不需要访问共享内存</li>
<li>纯函数不会因为副作用而进入竞争态</li>
<li>所以纯函数可以并行</li>
</ul>
</li>
</ul>
<h3 id="介绍两种写纯函数的工具">介绍两种写纯函数的&quot;工具&quot;</h3>
<h4 id="柯里化curry">柯里化(curry)</h4>
<p>只传递给函数一部分参数去调用它，让它返回一个函数去处理剩下的参数<br>一个简单的例子：</p>
<pre><code class="language-javascript"><span class="hljs-keyword">const</span> add = <span class="hljs-keyword">function</span> (<span class="hljs-params">x</span>) {
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span> (<span class="hljs-params">y</span>) {
    <span class="hljs-keyword">return</span> x + y;
  };
};

<span class="hljs-keyword">const</span> increment = <span class="hljs-title function_">add</span>(<span class="hljs-number">1</span>);
<span class="hljs-keyword">const</span> addTen = <span class="hljs-title function_">add</span>(<span class="hljs-number">10</span>);

<span class="hljs-title function_">increment</span>(<span class="hljs-number">2</span>); <span class="hljs-comment">// 3</span>

<span class="hljs-title function_">addTen</span>(<span class="hljs-number">2</span>); <span class="hljs-comment">// 12</span>
</code></pre>
<p>这里表明的是一种“预加载”函数的能力，通过传递一到两个参数调用函数，就能得到一个记住了这些参数的新函数。</p>
<p><strong>使用 lodash</strong></p>
<pre><code class="language-javascript"><span class="hljs-keyword">const</span> _ = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;lodash&quot;</span>);
<span class="hljs-keyword">const</span> abc = <span class="hljs-keyword">function</span> (<span class="hljs-params">a, b, c</span>) {
  <span class="hljs-keyword">return</span> [a, b, c];
};

<span class="hljs-keyword">const</span> curry = _.<span class="hljs-title function_">curry</span>(abc);

<span class="hljs-title function_">curry</span>(<span class="hljs-number">1</span>)(<span class="hljs-number">2</span>)(<span class="hljs-number">3</span>);
<span class="hljs-comment">// =&gt; [1, 2, 3]</span>

<span class="hljs-title function_">curry</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>)(<span class="hljs-number">3</span>);
<span class="hljs-comment">// =&gt; [1, 2, 3]</span>

<span class="hljs-title function_">curry</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>);
<span class="hljs-comment">// =&gt; [1, 2, 3]</span>

<span class="hljs-comment">// 第二次调用时候，在第二个参数位置用 _ 占位，可以先传第三个参数，再传第二个参数</span>
<span class="hljs-title function_">curry</span>(<span class="hljs-number">1</span>)(_, <span class="hljs-number">3</span>)(<span class="hljs-number">2</span>);
<span class="hljs-comment">// =&gt; [1, 2, 3]</span>

<span class="hljs-keyword">const</span> match = <span class="hljs-title function_">curry</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params">what， str</span>) {
  <span class="hljs-keyword">return</span> str.<span class="hljs-title function_">match</span>(what);
});

<span class="hljs-keyword">const</span> hasSpaces = <span class="hljs-title function_">match</span>(<span class="hljs-regexp">/\s+/g</span>);
<span class="hljs-title function_">hasSpaces</span>(<span class="hljs-string">&quot;hello world&quot;</span>); <span class="hljs-comment">// [&#x27; &#x27;]</span>
<span class="hljs-title function_">hasSpaces</span>(<span class="hljs-string">&quot;spaceless&quot;</span>); <span class="hljs-comment">// null</span>
</code></pre>
<p>这种能力，类似于一种&quot;继承&quot;。 &quot;子函数&quot; 继承 &quot;父函数&quot;的运算能力，通过简单传递几个参数，就能动态创建使用的新函数，并且保留了数学函数的定义。</p>
<h4 id="代码组合compose">代码组合(compose)</h4>
<p>组合的简单实现：</p>
<pre><code class="language-javascript"><span class="hljs-keyword">const</span> compose = <span class="hljs-keyword">function</span> (<span class="hljs-params">f, g</span>) {
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span> (<span class="hljs-params">x</span>) {
    <span class="hljs-keyword">return</span> <span class="hljs-title function_">f</span>(<span class="hljs-title function_">g</span>(x));
  };
};

<span class="hljs-keyword">const</span> <span class="hljs-title function_">toUpperCase</span> = (<span class="hljs-params">x</span>) =&gt; x.<span class="hljs-title function_">toUpperCase</span>();
<span class="hljs-keyword">const</span> <span class="hljs-title function_">exclaim</span> = (<span class="hljs-params">x</span>) =&gt; x + <span class="hljs-string">&quot;!&quot;</span>;
<span class="hljs-keyword">const</span> shout = <span class="hljs-title function_">compose</span>(exclaim， toUpperCase);

<span class="hljs-title function_">shout</span>(<span class="hljs-string">&quot;send in the clowns&quot;</span>); <span class="hljs-comment">//=&gt; &quot;SEND IN THE CLOWNS!&quot;</span>

<span class="hljs-comment">// 不用组合的 shout 函数</span>
<span class="hljs-keyword">const</span> shout = <span class="hljs-keyword">function</span> (<span class="hljs-params">x</span>) {
  <span class="hljs-keyword">return</span> <span class="hljs-title function_">exclaim</span>(<span class="hljs-title function_">toUpperCase</span>(x));
};
</code></pre>
<p>组合将代码的由内向外运行改为了从右向左运行，避免了嵌套层级太深导致代码逻辑难以捋清的情况。类似 Promise 对回调地狱的拯救。<br>组合像一系列管道那样把不同的函数联系在一起，数据就可以也必须在其中流动。</p>
<h3 id="最后">最后</h3>
<p>如果你觉得函数式编程会增加代码的复杂性、可读性，不要使用它!</p>
<p>实际上，有些函数式编程中的工具函数会将代码变得阅读困难，并不是书里介绍的那样&quot;让我们的代码简单而富有可读性&quot;。</p>
<p>介绍函数式编程不是要大家全部去使用函数式编程，而是介绍一种函数的思想，我认为它优秀的思想在以下几点：</p>
<ul>
<li>相同的输入永远会得到相同的输出</li>
<li>纯函数不依赖环境变量，如果要依赖，将环境变量作为参数传进去，而不是&quot;偷偷&quot;使用。</li>
<li>处理复杂对象的函数最佳实践是：<strong>传入复杂对象</strong> -&gt; <strong>处理</strong> -&gt; <strong>传出这个对象</strong> (如果可能的话，可以 <strong>深复制这个对象</strong> -&gt; <strong>处理新对象</strong> -&gt; <strong>传出这个新对象</strong>)</li>
<li>将系统功能拆分成尽可能小的单元模块，每个单元尽可能使用纯函数去实现功能，形成一个业务纯函数池。函数池中的功能模块提供给所有上层功能使用，提高软件的可移植性和可扩展性。(这不就是 lodash 干的事情吗)</li>
</ul>

  </body>
</html>

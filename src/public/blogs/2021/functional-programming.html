<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><meta name="keywords" content="javascript,函数式编程,zhangxuekang,zhangxk"><link rel="shortcut icon" href="https://zhangxuekang.github.io/src/zhangxk.ico" type="image/x-icon"><title>zhangxk-函数式编程笔记</title><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.2.0/styles/default.min.css"><style>a,abbr,acronym,address,applet,article,aside,audio,b,big,blockquote,body,canvas,caption,center,cite,code,dd,del,details,dfn,div,dl,dt,em,embed,fieldset,figcaption,figure,footer,form,h1,h2,h3,h4,h5,h6,header,hgroup,html,i,iframe,img,ins,kbd,label,legend,li,mark,menu,nav,object,ol,output,p,pre,q,ruby,s,samp,section,small,span,strike,strong,sub,summary,sup,table,tbody,td,tfoot,th,thead,time,tr,tt,u,ul,var,video{margin:0;padding:0;border:0;font:inherit;vertical-align:baseline}article,aside,details,figcaption,figure,footer,header,hgroup,menu,nav,section{display:block}ol,ul{list-style:none}table{border-collapse:collapse;border-spacing:0}body{box-sizing:border-box;color:#373737;background:#212121;font-size:16px;font-family:"Myriad Pro",Calibri,Helvetica,Arial,sans-serif;line-height:1.5;-webkit-font-smoothing:antialiased}h1,h2,h3,h4,h5,h6{margin:10px 0;font-weight:700;color:#222;font-family:"Lucida Grande",Calibri,Helvetica,Arial,sans-serif;letter-spacing:-1px}h1{font-size:36px;font-weight:700}h2{margin-bottom:20px;font-size:32px;border-bottom:1px dashed #dadada}h3{font-size:24px}h4{font-size:21px}h5{font-size:18px}h6{font-size:16px}p{margin:10px 0 15px 0}footer p{color:#f2f2f2}a{text-decoration:none;color:#0f79d0;text-shadow:none;transition:color .5s ease;transition:text-shadow .5s ease;-webkit-transition:color .5s ease;-webkit-transition:text-shadow .5s ease;-moz-transition:color .5s ease;-moz-transition:text-shadow .5s ease;-o-transition:color .5s ease;-o-transition:text-shadow .5s ease;-ms-transition:color .5s ease;-ms-transition:text-shadow .5s ease}a:focus,a:hover{text-decoration:underline}footer a{color:#f2f2f2;text-decoration:underline}cite,em{font-style:italic}strong{font-weight:700}img{position:relative;margin:0 auto;max-width:739px;padding:5px;margin:10px 0 10px 0;border:1px solid #ebebeb;box-shadow:0 0 5px #ebebeb;-webkit-box-shadow:0 0 5px #ebebeb;-moz-box-shadow:0 0 5px #ebebeb;-o-box-shadow:0 0 5px #ebebeb;-ms-box-shadow:0 0 5px #ebebeb}p img{display:inline;margin:0;padding:0;vertical-align:middle;text-align:center;border:none}code,pre{color:#222;font-family:Monaco,"Bitstream Vera Sans Mono","Lucida Console",Terminal,monospace;font-size:.875em;border-radius:2px;-moz-border-radius:2px;-webkit-border-radius:2px}pre{padding:10px;box-shadow:0 0 10px rgba(0,0,0,.1);overflow:auto}code{padding:3px;margin:0 3px;box-shadow:0 0 10px rgba(0,0,0,.1)}pre code{display:block;box-shadow:none}blockquote{color:#666;margin-bottom:20px;padding:0 0 0 20px;border-left:3px solid #bbb}dl,ol,ul{margin-bottom:15px}ul{list-style-position:inside;list-style:disc;padding-left:20px}ol{list-style-position:inside;list-style:decimal;padding-left:20px}dl dt{font-weight:700}dl dd{padding-left:20px;font-style:italic}dl p{padding-left:20px;font-style:italic}hr{height:1px;margin-bottom:5px;border:none;background:url(../images/bg_hr.png) repeat-x center}table{border:1px solid #373737;margin-bottom:20px;margin-top:10px;text-align:left}th{font-family:"Lucida Grande","Helvetica Neue",Helvetica,Arial,sans-serif;padding:10px;background:#373737;color:#fff}td{padding:10px;border:1px solid #373737}form{background:#f2f2f2;padding:20px}kbd{background-color:#fafbfc;border:1px solid #c6cbd1;border-bottom-color:#959da5;border-radius:3px;box-shadow:inset 0 -1px 0 #959da5;color:#444d56;display:inline-block;font-size:11px;line-height:11px;padding:3px 5px;vertical-align:middle}.outer{width:100%}.inner{position:relative;max-width:640px;padding:20px 10px;margin:0 auto}#header_wrap{background:#212121;background:-moz-linear-gradient(top,#373737,#212121);background:-webkit-linear-gradient(top,#373737,#212121);background:-ms-linear-gradient(top,#373737,#212121);background:-o-linear-gradient(top,#373737,#212121);background:linear-gradient(to top,#373737,#212121)}#header_wrap .inner{padding:50px 10px 30px 10px}#project_title{margin:0;color:#fff;font-size:42px;font-weight:700;text-shadow:#111 0 0 10px}#project_tagline{color:#222;font-weight:300;background:0 0;text-shadow:#111 0 0 10px;border-bottom:none}#project_tagline span{display:inline-block;height:33px;font-size:13px;line-height:33px;overflow:hidden;margin-bottom:10px;margin-right:10px;padding:0 12px;border-radius:100px;background:rgba(242,242,242,.5)}#project_time{color:#fff;text-shadow:#111 0 0 10px}#main_content_wrap{background:#f2f2f2;border-bottom:1px solid #111}#main_content{padding-top:40px}#footer_wrap{background:#212121}@media screen and (max-width:992px){img{max-width:100%}}@media screen and (max-width:480px){body{font-size:14px}#downloads{display:none}.inner{min-width:320px;max-width:480px}#project_title{font-size:32px}h1{font-size:28px}h2{font-size:24px}h3{font-size:21px}h4{font-size:18px}h5{font-size:14px}h6{font-size:12px}code,pre{font-size:11px}}@media screen and (max-width:320px){body{font-size:14px}#downloads{display:none}.inner{min-width:240px;max-width:320px}#project_title{font-size:28px}h1{font-size:24px}h2{font-size:21px}h3{font-size:18px}h4{font-size:16px}h5{font-size:14px}h6{font-size:12px}code,pre{min-width:240px;max-width:320px;font-size:11px}}#header_wrap{width:100%;background-size:cover;background-image:url(https://source.unsplash.com/1200x180/?nature,water)}pre{white-space:pre;word-wrap:normal;background:#282936}pre code{color:#e9e9f4;background:#262822}.cnblogs-markdown .hljs{display:block;overflow:auto;padding:1.3em 2em!important;font-size:16px!important;background:#272822!important;color:#fff;max-height:700px}.hljs,.hljs-subst,.hljs-tag{color:#f8f8f2}.hljs-emphasis,.hljs-strong{color:#a8a8a2}.hljs-bullet,.hljs-link,.hljs-literal,.hljs-number,.hljs-quote,.hljs-regexp{color:#ae81ff}.hljs-code,.hljs-section,.hljs-selector-class,.hljs-title{color:#a6e22e}.hljs-strong{font-weight:700}.hljs-emphasis{font-style:italic}.hljs-attr,.hljs-keyword,.hljs-name,.hljs-selector-tag{color:#f92672}.hljs-attribute,.hljs-symbol{color:#66d9ef}.hljs-class .hljs-title,.hljs-params{color:#f8f8f2}.hljs-addition,.hljs-built_in,.hljs-builtin-name,.hljs-selector-attr,.hljs-selector-id,.hljs-selector-pseudo,.hljs-string,.hljs-template-variable,.hljs-type,.hljs-variable{color:#e6db74}.hljs-comment,.hljs-deletion,.hljs-meta{color:#75715e}p>code{color:#c7254e;border:none!important;font-size:1em!important;background-color:#f9f2f4!important;font-weight:500;font-family:Monaco,"Bitstream Vera Sans Mono","Lucida Console",Terminal!important}</style></head><body><div id="header_wrap" class="outer"><header class="inner"><h1 id="project_title">函数式编程笔记</h1><p id="project_tagline"><span>javascript</span><span>函数式编程</span></p><p id="project_time">发布于 2021</p></header></div><div id="main_content_wrap" class="outer"><section id="main_content" class="inner"><h1 id="函数式编程">函数式编程</h1><p>什么是函数式编程？</p><p>维基百科定义：</p><blockquote><p>函数式编程[Functional Programming]是一种编程模型，他将计算机运算看做是数学中函数的计算，并且避免了状态以及变量的概念。</p></blockquote><p>函数式编程和过程式编程有什么区别？</p><p>举个栗子，现在有一个这样的表达式：</p><pre><code class="language-javascript">(<span class="hljs-number">1</span> + <span class="hljs-number">2</span>) * <span class="hljs-number">3</span> - <span class="hljs-number">4</span>;
</code></pre><p>过程式编程可能是这样实现的：</p><pre><code class="language-javascript"><span class="hljs-keyword">const</span> a = <span class="hljs-number">1</span> + <span class="hljs-number">2</span>;
<span class="hljs-keyword">const</span> b = a * <span class="hljs-number">3</span>;
<span class="hljs-keyword">const</span> c = b - <span class="hljs-number">4</span>;
</code></pre><p>使用函数式编程会将计算过程定义为不同的函数，依次调用函数：</p><pre><code class="language-javascript"><span class="hljs-keyword">const</span> result = <span class="hljs-title function_">subtract</span>(<span class="hljs-title function_">multiply</span>(<span class="hljs-title function_">add</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>), <span class="hljs-number">3</span>), <span class="hljs-number">4</span>);
</code></pre><p>除了调用函数，一点多余的代码都不需要写。这些函数甚至不用自己定义，各种函数库随你使用。</p><h3 id="函数式编程的特点">函数式编程的特点</h3><ol><li>函数是&quot;第一等公民&quot;<ul><li>所谓&quot;第一等公民&quot;（first class），指的是函数与其他数据类型一样，处于平等地位，可以赋值给其他变量，也可以作为参数，传入另一个函数，或者作为别的函数的返回值。javascript 中的函数天生就是一等公民。</li><li>举例来说 print 变量就是一个函数，可以作为另一个函数的参数</li></ul></li></ol><pre><code class="language-javascript"><span class="hljs-keyword">const</span> <span class="hljs-title function_">print</span> = (<span class="hljs-params">v</span>) =&gt; <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(v);
[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>].<span class="hljs-title function_">forEach</span>(print);
</code></pre><ul><li>理解函数是一等公民的本质，会让你删除很多无用的间接层代码。</li></ul><pre><code class="language-javascript"><span class="hljs-keyword">const</span> <span class="hljs-title function_">getServerStuff</span> = (<span class="hljs-params">callback</span>) =&gt; <span class="hljs-title function_">ajaxCall</span>(<span class="hljs-function">(<span class="hljs-params">json</span>) =&gt;</span> <span class="hljs-title function_">callback</span>(json));
<span class="hljs-comment">// 等价于</span>
<span class="hljs-keyword">const</span> getServerStuff = ajaxCall;

<span class="hljs-comment">// 逐步分析</span>
<span class="hljs-comment">// const fn = (json) =&gt; callback(json);</span>
<span class="hljs-comment">// fn(&#x27;abc&#x27;) -&gt; callback(&#x27;abc&#x27;)</span>
<span class="hljs-comment">// fn -&gt; callback</span>
<span class="hljs-comment">// 这行</span>
<span class="hljs-title function_">ajaxCall</span>(<span class="hljs-function">(<span class="hljs-params">json</span>) =&gt;</span> <span class="hljs-title function_">callback</span>(json));

<span class="hljs-comment">// 等价于这行</span>
<span class="hljs-title function_">ajaxCall</span>(callback);

<span class="hljs-comment">// 那么，重构下 getServerStuff</span>
<span class="hljs-keyword">const</span> <span class="hljs-title function_">getServerStuff</span> = (<span class="hljs-params">callback</span>) =&gt; <span class="hljs-title function_">ajaxCall</span>(callback);

<span class="hljs-comment">// ...就等于</span>
<span class="hljs-keyword">const</span> getServerStuff = ajaxCall;
</code></pre><ol><li>只用&quot;表达式&quot;，不用&quot;语句&quot;<ul><li>&quot;表达式&quot;（expression）是一个单纯的运算过程，总是有返回值；&quot;语句&quot;（statement）是执行某种操作，没有返回值。</li><li>函数式编程要求每一步都是单纯的运算，而且都有返回值。</li><li>函数式编程的动机是进行运算。</li></ul></li><li>没有&quot;副作用&quot;<ul><li>所谓&quot;副作用&quot;（side effect），指的是函数内部与外部互动（最典型的情况，就是修改全局变量的值），产生运算以外的其他结果。</li><li>函数式编程不考虑系统的读写（I/O）。</li><li>函数要保持独立，不得修改外部变量的值。</li></ul></li><li>不修改状态<ul><li>强调不修改外部变量</li></ul></li><li>引用透明<ul><li>引用透明（Referential transparency），指的是函数的运行不依赖于外部变量或&quot;状态&quot;，只依赖于输入的参数，任何时候只要参数相同，引用函数所得到的返回值总是相同的。</li></ul></li></ol><h4 id="this">this</h4><p>值得一提的是，函数式编程不建议在函数中使用<code>this</code>关键字，因为<code>this</code>的行为依赖函数运行的实际情况。而函数式编程要求无论何时，无论是谁调用这个函数，只要输入参数一样，必然能输出相同的结果。</p><h3 id="纯函数的好处">纯函数的好处</h3><p><strong><code>&quot;纯&quot;</code></strong> ：相同的输入，永远会得到相同的输出，而且没有任何可观察的副作用。</p><pre><code class="language-javascript"><span class="hljs-keyword">var</span> xs = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>];

<span class="hljs-comment">// 纯的</span>
xs.<span class="hljs-title function_">slice</span>(<span class="hljs-number">0</span>, <span class="hljs-number">3</span>);
<span class="hljs-comment">//=&gt; [1,2,3].</span>
xs.<span class="hljs-title function_">slice</span>(<span class="hljs-number">0</span>, <span class="hljs-number">3</span>);
<span class="hljs-comment">//=&gt; [1,2,3]</span>
xs.<span class="hljs-title function_">slice</span>(<span class="hljs-number">0</span>, <span class="hljs-number">3</span>);
<span class="hljs-comment">//=&gt; [1,2,3]</span>

<span class="hljs-comment">// 不纯的</span>
xs.<span class="hljs-title function_">splice</span>(<span class="hljs-number">0</span>, <span class="hljs-number">3</span>);
<span class="hljs-comment">//=&gt; [1,2,3]</span>
xs.<span class="hljs-title function_">splice</span>(<span class="hljs-number">0</span>, <span class="hljs-number">3</span>);
<span class="hljs-comment">//=&gt; [4,5]</span>
xs.<span class="hljs-title function_">splice</span>(<span class="hljs-number">0</span>, <span class="hljs-number">3</span>);
<span class="hljs-comment">//=&gt; []</span>
</code></pre><blockquote><p>副作用是在计算结果的过程中，系统状态的一种变化，或者与外部世界进行的可观察的交互。</p></blockquote><p>副作用可能包含，但不限于：</p><ul><li>更改文件系统</li><li>往数据库插入记录</li><li>发送一个 http 请求</li><li>可变数据</li><li>打印/log</li><li>获取用户输入</li><li>DOM 查询</li><li>访问系统状态</li></ul><p>一个系统不可能不产生副作用而单独运行，函数式编程要让副作用在可控的范围内发生。<br>(函数式编程的部分，更像是计算机系统中的 CPU 角色，负责底层逻辑的运算)</p><h4 id="追求纯的理由">追求“纯”的理由</h4><ul><li>可缓存性（Cacheable）<ul><li>因为纯函数对相同的输入总是产生相同的输入，所以完全可以缓存结果</li><li>缓存过的纯函数，相同参数运行过一次，再次运行时，直接从缓存中读取结果，省去了计算过程</li></ul></li></ul><pre><code class="language-javascript"><span class="hljs-keyword">const</span> memoize = <span class="hljs-keyword">function</span> (<span class="hljs-params">f</span>) {
  <span class="hljs-keyword">const</span> cache = {};
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) {
    <span class="hljs-keyword">var</span> arg_str = <span class="hljs-variable constant_">JSON</span>.<span class="hljs-title function_">stringify</span>(<span class="hljs-variable language_">arguments</span>);
    cache[arg_str] = cache[arg_str] || f.<span class="hljs-title function_">apply</span>(f, <span class="hljs-variable language_">arguments</span>);
    <span class="hljs-keyword">return</span> cache[arg_str];
  };
};
</code></pre><ul><li>可移植性／自文档化（Portable / Self-Documenting）<ul><li>纯函数是&quot;自给自足&quot;的， 纯函数的依赖很明确。 需要什么资源，就必须当做参数传进去。</li><li>纯函数可以毫无压力的移植到不同项目中使用。</li></ul></li></ul><pre><code class="language-javascript">    <span class="hljs-comment">// 不纯的，只能在当前Db数据库中使用</span>
    <span class="hljs-keyword">var</span> saveUser = <span class="hljs-keyword">function</span>(<span class="hljs-params">attrs</span>) {
       <span class="hljs-keyword">var</span> user = <span class="hljs-title class_">Db</span>.<span class="hljs-title function_">save</span>(attrs);
       ...
    ;
    <span class="hljs-comment">// 纯的， 函数可移植到任何数据库使用</span>
    <span class="hljs-keyword">var</span> saveUser = <span class="hljs-keyword">function</span>(<span class="hljs-params">attrs， Db</span>) {
       <span class="hljs-keyword">var</span> user = <span class="hljs-title class_">Db</span>.<span class="hljs-title function_">save</span>(attrs);
       ...
    ;
</code></pre><ul><li><p>可测试性（Testable）</p><ul><li>因为纯函数对每次相同输入都有相同的输入，并且纯函数的不依赖运行的环境因素，所以做单元测试的时候更加容易。</li></ul></li><li><p>合理性（Reasonable）</p><ul><li><p>引用透明</p><blockquote><p>如果一段代码可以替换成它执行所得的结果，而且是在不改变整个程序行为的前提下替换的，那么我们就说这段代码是引用透明的。</p></blockquote></li><li><p>纯函数保证了引用透明。</p></li><li><p>使用纯函数编写的程序代码，更容易分模块，更容易被理解分析</p></li></ul></li><li><p>并行代码</p><ul><li>纯函数不需要访问共享内存</li><li>纯函数不会因为副作用而进入竞争态</li><li>所以纯函数可以并行</li></ul></li></ul><h3 id="介绍两种写纯函数的工具">介绍两种写纯函数的&quot;工具&quot;</h3><h4 id="柯里化curry">柯里化(curry)</h4><p>只传递给函数一部分参数去调用它，让它返回一个函数去处理剩下的参数<br>一个简单的例子：</p><pre><code class="language-javascript"><span class="hljs-keyword">const</span> add = <span class="hljs-keyword">function</span> (<span class="hljs-params">x</span>) {
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span> (<span class="hljs-params">y</span>) {
    <span class="hljs-keyword">return</span> x + y;
  };
};

<span class="hljs-keyword">const</span> increment = <span class="hljs-title function_">add</span>(<span class="hljs-number">1</span>);
<span class="hljs-keyword">const</span> addTen = <span class="hljs-title function_">add</span>(<span class="hljs-number">10</span>);

<span class="hljs-title function_">increment</span>(<span class="hljs-number">2</span>); <span class="hljs-comment">// 3</span>

<span class="hljs-title function_">addTen</span>(<span class="hljs-number">2</span>); <span class="hljs-comment">// 12</span>
</code></pre><p>这里表明的是一种“预加载”函数的能力，通过传递一到两个参数调用函数，就能得到一个记住了这些参数的新函数。</p><p><strong>使用 lodash</strong></p><pre><code class="language-javascript"><span class="hljs-keyword">const</span> _ = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;lodash&quot;</span>);
<span class="hljs-keyword">const</span> abc = <span class="hljs-keyword">function</span> (<span class="hljs-params">a, b, c</span>) {
  <span class="hljs-keyword">return</span> [a, b, c];
};

<span class="hljs-keyword">const</span> curry = _.<span class="hljs-title function_">curry</span>(abc);

<span class="hljs-title function_">curry</span>(<span class="hljs-number">1</span>)(<span class="hljs-number">2</span>)(<span class="hljs-number">3</span>);
<span class="hljs-comment">// =&gt; [1, 2, 3]</span>

<span class="hljs-title function_">curry</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>)(<span class="hljs-number">3</span>);
<span class="hljs-comment">// =&gt; [1, 2, 3]</span>

<span class="hljs-title function_">curry</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>);
<span class="hljs-comment">// =&gt; [1, 2, 3]</span>

<span class="hljs-comment">// 第二次调用时候，在第二个参数位置用 _ 占位，可以先传第三个参数，再传第二个参数</span>
<span class="hljs-title function_">curry</span>(<span class="hljs-number">1</span>)(_, <span class="hljs-number">3</span>)(<span class="hljs-number">2</span>);
<span class="hljs-comment">// =&gt; [1, 2, 3]</span>

<span class="hljs-keyword">const</span> match = <span class="hljs-title function_">curry</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params">what， str</span>) {
  <span class="hljs-keyword">return</span> str.<span class="hljs-title function_">match</span>(what);
});

<span class="hljs-keyword">const</span> hasSpaces = <span class="hljs-title function_">match</span>(<span class="hljs-regexp">/\s+/g</span>);
<span class="hljs-title function_">hasSpaces</span>(<span class="hljs-string">&quot;hello world&quot;</span>); <span class="hljs-comment">// [&#x27; &#x27;]</span>
<span class="hljs-title function_">hasSpaces</span>(<span class="hljs-string">&quot;spaceless&quot;</span>); <span class="hljs-comment">// null</span>
</code></pre><p>这种能力，类似于一种&quot;继承&quot;。 &quot;子函数&quot; 继承 &quot;父函数&quot;的运算能力，通过简单传递几个参数，就能动态创建使用的新函数，并且保留了数学函数的定义。</p><h4 id="代码组合compose">代码组合(compose)</h4><p>组合的简单实现：</p><pre><code class="language-javascript"><span class="hljs-keyword">const</span> compose = <span class="hljs-keyword">function</span> (<span class="hljs-params">f, g</span>) {
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span> (<span class="hljs-params">x</span>) {
    <span class="hljs-keyword">return</span> <span class="hljs-title function_">f</span>(<span class="hljs-title function_">g</span>(x));
  };
};

<span class="hljs-keyword">const</span> <span class="hljs-title function_">toUpperCase</span> = (<span class="hljs-params">x</span>) =&gt; x.<span class="hljs-title function_">toUpperCase</span>();
<span class="hljs-keyword">const</span> <span class="hljs-title function_">exclaim</span> = (<span class="hljs-params">x</span>) =&gt; x + <span class="hljs-string">&quot;!&quot;</span>;
<span class="hljs-keyword">const</span> shout = <span class="hljs-title function_">compose</span>(exclaim， toUpperCase);

<span class="hljs-title function_">shout</span>(<span class="hljs-string">&quot;send in the clowns&quot;</span>); <span class="hljs-comment">//=&gt; &quot;SEND IN THE CLOWNS!&quot;</span>

<span class="hljs-comment">// 不用组合的 shout 函数</span>
<span class="hljs-keyword">const</span> shout = <span class="hljs-keyword">function</span> (<span class="hljs-params">x</span>) {
  <span class="hljs-keyword">return</span> <span class="hljs-title function_">exclaim</span>(<span class="hljs-title function_">toUpperCase</span>(x));
};
</code></pre><p>组合将代码的由内向外运行改为了从右向左运行，避免了嵌套层级太深导致代码逻辑难以捋清的情况。类似 Promise 对回调地狱的拯救。<br>组合像一系列管道那样把不同的函数联系在一起，数据就可以也必须在其中流动。</p><h3 id="最后">最后</h3><p>如果你觉得函数式编程会增加代码的复杂性、可读性，不要使用它!</p><p>实际上，有些函数式编程中的工具函数会将代码变得阅读困难，并不是书里介绍的那样&quot;让我们的代码简单而富有可读性&quot;。</p><p>介绍函数式编程不是要大家全部去使用函数式编程，而是介绍一种函数的思想，我认为它优秀的思想在以下几点：</p><ul><li>相同的输入永远会得到相同的输出</li><li>纯函数不依赖环境变量，如果要依赖，将环境变量作为参数传进去，而不是&quot;偷偷&quot;使用。</li><li>处理复杂对象的函数最佳实践是：<strong>传入复杂对象</strong> -&gt; <strong>处理</strong> -&gt; <strong>传出这个对象</strong> (如果可能的话，可以 <strong>深复制这个对象</strong> -&gt; <strong>处理新对象</strong> -&gt; <strong>传出这个新对象</strong>)</li><li>将系统功能拆分成尽可能小的单元模块，每个单元尽可能使用纯函数去实现功能，形成一个业务纯函数池。函数池中的功能模块提供给所有上层功能使用，提高软件的可移植性和可扩展性。(这不就是 lodash 干的事情吗)</li></ul></section></div><div id="footer_wrap" class="outer"><footer class="inner"><p class="update-time">更新于 2021-10-09</p><p class="copyright">zhangxk-notes maintained by <a href="https://github.com/zhangxuekang">zhangxuekang</a></p></footer></div></body></html>
<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><meta name="keywords" content="javascript,svg,动画,zhangxuekang,zhangxk"><link rel="shortcut icon" href="https://zhangxuekang.github.io/src/zhangxk.ico" type="image/x-icon"><title>zhangxk-从两个需求说起 svg 路径动画</title><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.2.0/styles/default.min.css"><style>a,abbr,acronym,address,applet,article,aside,audio,b,big,blockquote,body,canvas,caption,center,cite,code,dd,del,details,dfn,div,dl,dt,em,embed,fieldset,figcaption,figure,footer,form,h1,h2,h3,h4,h5,h6,header,hgroup,html,i,iframe,img,ins,kbd,label,legend,li,mark,menu,nav,object,ol,output,p,pre,q,ruby,s,samp,section,small,span,strike,strong,sub,summary,sup,table,tbody,td,tfoot,th,thead,time,tr,tt,u,ul,var,video{margin:0;padding:0;border:0;font:inherit;vertical-align:baseline}article,aside,details,figcaption,figure,footer,header,hgroup,menu,nav,section{display:block}ol,ul{list-style:none}table{border-collapse:collapse;border-spacing:0}body{box-sizing:border-box;color:#373737;background:#212121;font-size:16px;font-family:"Myriad Pro",Calibri,Helvetica,Arial,sans-serif;line-height:1.5;-webkit-font-smoothing:antialiased}h1,h2,h3,h4,h5,h6{margin:10px 0;font-weight:700;color:#222;font-family:"Lucida Grande",Calibri,Helvetica,Arial,sans-serif;letter-spacing:-1px}h1{font-size:36px;font-weight:700}h2{margin-bottom:20px;font-size:32px;border-bottom:1px dashed #dadada}h3{font-size:24px}h4{font-size:21px}h5{font-size:18px}h6{font-size:16px}p{margin:10px 0 15px 0}footer p{color:#f2f2f2}a{text-decoration:none;color:#0f79d0;text-shadow:none;transition:color .5s ease;transition:text-shadow .5s ease;-webkit-transition:color .5s ease;-webkit-transition:text-shadow .5s ease;-moz-transition:color .5s ease;-moz-transition:text-shadow .5s ease;-o-transition:color .5s ease;-o-transition:text-shadow .5s ease;-ms-transition:color .5s ease;-ms-transition:text-shadow .5s ease}a:focus,a:hover{text-decoration:underline}footer a{color:#f2f2f2;text-decoration:underline}cite,em{font-style:italic}strong{font-weight:700}img{position:relative;margin:0 auto;max-width:739px;padding:5px;margin:10px 0 10px 0;border:1px solid #ebebeb;box-shadow:0 0 5px #ebebeb;-webkit-box-shadow:0 0 5px #ebebeb;-moz-box-shadow:0 0 5px #ebebeb;-o-box-shadow:0 0 5px #ebebeb;-ms-box-shadow:0 0 5px #ebebeb}p img{display:inline;margin:0;padding:0;vertical-align:middle;text-align:center;border:none}code,pre{color:#222;font-family:Monaco,"Bitstream Vera Sans Mono","Lucida Console",Terminal,monospace;font-size:.875em;border-radius:2px;-moz-border-radius:2px;-webkit-border-radius:2px}pre{padding:10px;box-shadow:0 0 10px rgba(0,0,0,.1);overflow:auto}code{padding:3px;margin:0 3px;box-shadow:0 0 10px rgba(0,0,0,.1)}pre code{display:block;box-shadow:none}blockquote{color:#666;margin-bottom:20px;padding:0 0 0 20px;border-left:3px solid #bbb}dl,ol,ul{margin-bottom:15px}ul{list-style-position:inside;list-style:disc;padding-left:20px}ol{list-style-position:inside;list-style:decimal;padding-left:20px}dl dt{font-weight:700}dl dd{padding-left:20px;font-style:italic}dl p{padding-left:20px;font-style:italic}hr{height:1px;margin-bottom:5px;border:none;background:url(../images/bg_hr.png) repeat-x center}table{border:1px solid #373737;margin-bottom:20px;margin-top:10px;text-align:left}th{font-family:"Lucida Grande","Helvetica Neue",Helvetica,Arial,sans-serif;padding:10px;background:#373737;color:#fff}td{padding:10px;border:1px solid #373737}form{background:#f2f2f2;padding:20px}kbd{background-color:#fafbfc;border:1px solid #c6cbd1;border-bottom-color:#959da5;border-radius:3px;box-shadow:inset 0 -1px 0 #959da5;color:#444d56;display:inline-block;font-size:11px;line-height:11px;padding:3px 5px;vertical-align:middle}.outer{width:100%}.inner{position:relative;max-width:640px;padding:20px 10px;margin:0 auto}#header_wrap{background:#212121;background:-moz-linear-gradient(top,#373737,#212121);background:-webkit-linear-gradient(top,#373737,#212121);background:-ms-linear-gradient(top,#373737,#212121);background:-o-linear-gradient(top,#373737,#212121);background:linear-gradient(to top,#373737,#212121)}#header_wrap .inner{padding:50px 10px 30px 10px}#project_title{margin:0;color:#fff;font-size:42px;font-weight:700;text-shadow:#111 0 0 10px}#project_tagline{color:#222;font-weight:300;background:0 0;text-shadow:#111 0 0 10px;border-bottom:none}#project_tagline span{display:inline-block;height:33px;font-size:13px;line-height:33px;overflow:hidden;margin-bottom:10px;margin-right:10px;padding:0 12px;border-radius:100px;background:rgba(242,242,242,.5)}#project_time{color:#fff;text-shadow:#111 0 0 10px}#main_content_wrap{background:#f2f2f2;border-bottom:1px solid #111}#main_content{padding-top:40px}#footer_wrap{background:#212121}@media screen and (max-width:992px){img{max-width:100%}}@media screen and (max-width:480px){body{font-size:14px}#downloads{display:none}.inner{min-width:320px;max-width:480px}#project_title{font-size:32px}h1{font-size:28px}h2{font-size:24px}h3{font-size:21px}h4{font-size:18px}h5{font-size:14px}h6{font-size:12px}code,pre{font-size:11px}}@media screen and (max-width:320px){body{font-size:14px}#downloads{display:none}.inner{min-width:240px;max-width:320px}#project_title{font-size:28px}h1{font-size:24px}h2{font-size:21px}h3{font-size:18px}h4{font-size:16px}h5{font-size:14px}h6{font-size:12px}code,pre{min-width:240px;max-width:320px;font-size:11px}}#header_wrap{width:100%;background-size:cover;background-image:url(https://source.unsplash.com/1200x180/?nature,water)}pre{white-space:pre;word-wrap:normal;background:#282936}pre code{color:#e9e9f4;background:#262822}.cnblogs-markdown .hljs{display:block;overflow:auto;padding:1.3em 2em!important;font-size:16px!important;background:#272822!important;color:#fff;max-height:700px}.hljs,.hljs-subst,.hljs-tag{color:#f8f8f2}.hljs-emphasis,.hljs-strong{color:#a8a8a2}.hljs-bullet,.hljs-link,.hljs-literal,.hljs-number,.hljs-quote,.hljs-regexp{color:#ae81ff}.hljs-code,.hljs-section,.hljs-selector-class,.hljs-title{color:#a6e22e}.hljs-strong{font-weight:700}.hljs-emphasis{font-style:italic}.hljs-attr,.hljs-keyword,.hljs-name,.hljs-selector-tag{color:#f92672}.hljs-attribute,.hljs-symbol{color:#66d9ef}.hljs-class .hljs-title,.hljs-params{color:#f8f8f2}.hljs-addition,.hljs-built_in,.hljs-builtin-name,.hljs-selector-attr,.hljs-selector-id,.hljs-selector-pseudo,.hljs-string,.hljs-template-variable,.hljs-type,.hljs-variable{color:#e6db74}.hljs-comment,.hljs-deletion,.hljs-meta{color:#75715e}p>code{color:#c7254e;border:none!important;font-size:1em!important;background-color:#f9f2f4!important;font-weight:500;font-family:Monaco,"Bitstream Vera Sans Mono","Lucida Console",Terminal!important}</style></head><body><div id="header_wrap" class="outer"><header class="inner"><h1 id="project_title">从两个需求说起 svg 路径动画</h1><p id="project_tagline"><span>javascript</span><span>svg</span><span>动画</span></p><p id="project_time">发布于 2020</p></header></div><div id="main_content_wrap" class="outer"><section id="main_content" class="inner"><h1 id="一、从一次需求说起">一、从一次需求说起</h1><p>在做一个在线课件的项目，类似于 web 端在线的 ppt 制作工具。制作课件避免不了各种进入退出动画，ppt 有的，公司工具也必须有。各种淡入淡出，从上、下、左、右方向飞出飞入，css3 动画安排上！正在我写的不亦乐乎，觉得微软入场动画也不过如此的时候，产品经理来了。“ppt 有的动画咱们工具必须有，ppt 没有的动画，咱么也要有！我们要让老师自定义动画，制作课件的时候用鼠标画出路径，然后保存路径数据，播放的时候元素沿着路径飞进来。” <img alt="飞入曲线" src="https://zhangxuekang.github.io/src/blog/path-animation/fly-path.png" width="40%"> 在我意识到产品经理不是在开玩笑的时候，我断然拒绝了接需求。当产品经理带着老板又来提这个需求的时候，我感觉到事情没这么简单······</p><p>最终还是我妥协了，自认为我还是刚不过老板的。</p><p><img alt="学会妥协" src="https://zhangxuekang.github.io/src/blog/path-animation/tuoxie.jpg" width="30%"> 这个需求，将我初中的知识用的淋漓尽致（感谢初中老师）。</p><h1 id="二、解决技术难题">二、解决技术难题</h1><p>要记录鼠标轨迹，一定要用到鼠标的 mousemove 事件，mousemove 事件能获取一系列的鼠标位置点，就可以控制元素一个点一个点“蹦”过去。在我脑补了一个青蛙沿着一个一个黑点跳过去的画面后，我马上放弃了这个想法。 <img alt="青蛙" src="https://zhangxuekang.github.io/src/blog/path-animation/qingwa.jpg" width="50%"> 动画移动是平滑的，绝对不是离散的。开始搜“如何将一系列离散的位置点拟合成平滑的曲线？”移步博客<a href="https://zhangxuekang.github.io/mouse-svg/"><em>记录鼠标轨迹, 生成 svg 路径</em></a>。</p><p>路径数据有了，是三次贝塞尔曲线，剩下的就是构建 svg 路径，让元素动起来了。</p><h2 id="如何让元素沿着-svg-曲线移动？">如何让元素沿着 svg 曲线移动？</h2><p><code>SVGPathElement</code>接口对应于<code>&lt;path&gt;</code>元素。这个接口有两个很有用的方法**<code>getTotalLength()</code><strong>和</strong><code>getPointAtLength()</code>**，前者得到 path 路径全长，后者传入长度得到坐标。</p><p>有了这些知识就可以做很多事情了，知道总长和总时间就可以知道速度，知道速度也知道当前走过的时间就可以算出当前走过的路程，知道当前的路程就知道了当前在 path 上的坐标，知道了当前坐标就能让元素就位了！很简单的路程速度与时间的方程，<code>s = vt</code>。</p><h3 id="撸代码">撸代码</h3><pre><code class="language-js"><span class="hljs-comment">// 首先构建出path元素</span>
<span class="hljs-keyword">const</span> path =
  <span class="hljs-string">&quot;M182,171 C183.25,171,185,171,187,171 C189,171,188.75,170.75,190,171 ......&quot;</span>;
<span class="hljs-keyword">const</span> pathEl = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">createElementNS</span>(<span class="hljs-string">&quot;http://www.w3.org/2000/svg&quot;</span>, <span class="hljs-string">&quot;path&quot;</span>);
pathEl.<span class="hljs-title function_">setAttribute</span>(<span class="hljs-string">&quot;d&quot;</span>, path);
<span class="hljs-comment">// 记录总时长，总长度和起始时间</span>
<span class="hljs-keyword">const</span> duration = <span class="hljs-number">2000</span>; <span class="hljs-comment">// ms</span>
<span class="hljs-keyword">const</span> totalLength = pathEl.<span class="hljs-title function_">getTotalLength</span>(); <span class="hljs-comment">// 总长</span>
<span class="hljs-keyword">let</span> curPosition = pathEl.<span class="hljs-title function_">getPointAtLength</span>(<span class="hljs-number">0</span>); <span class="hljs-comment">// 当前坐标,一开始是在起始点</span>
<span class="hljs-keyword">const</span> startTime = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>().<span class="hljs-title function_">getTime</span>(); <span class="hljs-comment">// 起始时间</span>

<span class="hljs-title function_">requestAnimationFrame</span>(step); <span class="hljs-comment">// js动画必备方法</span>
<span class="hljs-comment">// 动画前进一小步</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">step</span>(<span class="hljs-params"></span>) {
  <span class="hljs-keyword">const</span> nowTime = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>().<span class="hljs-title function_">getTime</span>();
  <span class="hljs-keyword">const</span> t = (nowTime - startTime) / duration; <span class="hljs-comment">// 时间进度 0~1</span>
  <span class="hljs-keyword">const</span> progress = totalLength * t; <span class="hljs-comment">// 当前走过的路程</span>
  curPosition = pathEl.<span class="hljs-title function_">getPointAtLength</span>(progress); <span class="hljs-comment">// 当前位置点的坐标</span>
  $e.<span class="hljs-property">style</span>.<span class="hljs-property">transform</span> = <span class="hljs-string">`translate(<span class="hljs-subst">${curPosition.x}</span>px, <span class="hljs-subst">${curPosition.y}</span>px)`</span>;
  <span class="hljs-keyword">if</span> (t &lt;= <span class="hljs-number">1</span>) {
    <span class="hljs-title function_">requestAnimationFrame</span>(step);
  }
}
</code></pre><p><a href="https://zhangxuekang.github.io/mouse-svg/">看 demo</a> <img alt="胜利" src="https://zhangxuekang.github.io/src/blog/path-animation/shengli.jpg" width="50%"></p><h1 id="又一次需求">又一次需求</h1><p>一个元素收起的动画，动点从不同的位置沿着不同的路径飞入同一个目标，就像这个样子。 <img alt="路径图" src="https://zhangxuekang.github.io/src/blog/path-animation/path.png" width="40%"> 有了上边的经验，实现起来就不慌了。 <img alt="不慌" src="https://zhangxuekang.github.io/src/blog/path-animation/buhuang.jpeg"> 沿着上边的思路，先确定 svg 路径，再确定时间（动效老师直接给出），完全没问题！</p><h2 id="确定路径">确定路径</h2><p>动效老师在了解到这是贝塞尔曲线后，马上给出了 24 个控制点的数据。因为起点一共有 12 个，终点有一个，这就有 12 条路径，每一条路径两个控制点，一共有 24 个控制点坐标。看着控制点坐标数据表格，我陷入了沉思，这咋维护？如果起点和终点的相对位置变了，岂不是需要重新计算 24 个控制点，这谁受得了？</p><p>理想情况是根据某种规律，由起点和终点的坐标计算出控制点坐标，起点和终点前端可以自己获取。经过观察，元素的移动路径是有规律的，起点在终点左边的点移动曲线向左弯曲，起点在终点右边的曲线向右弯曲，起点和终点的 x 坐标绝对值越大，曲线弧度越大，根据这些规律，完全可以得出一个公式。同时动效老师妥协了一步，将三次贝塞尔曲线改成了二次贝塞尔曲线（只需要一个控制点）。</p><p>由我提出控制点的计算公式，进过动效老师的确认，示意图如下。 <img alt="控制点示意图" src="https://zhangxuekang.github.io/src/blog/path-animation/jiexi.png" width="50%"> 接下来就是列公式求坐标了！ <img alt="控制点示意图1" src="https://zhangxuekang.github.io/src/blog/path-animation/f1.jpeg" width="50%"> 起始两点连线的中点坐标可以计算出来，还能计算出 L1 斜率，相差 90 度就是 L2 的斜率。那么，知道直线上一点坐标和直线的斜率，理论上可以计算出直线的解析方程，又知道在这个直线上一点计算另一个距离该点一定距离点的坐标······好麻烦！不会算 😂😂😂，要不要求助一下初中的数学老师 🤔？为了维护大学生的尊严，我又换了一种思路。</p><p><img alt="控制点示意图2" src="https://zhangxuekang.github.io/src/blog/path-animation/f2.jpeg" width="50%"> 大家都知道，三角形 1 和三角形 2 是相似三角形（不知道为什么的同学，主动去问初中数学老师），根据相似三角形理论写出代码：</p><pre><code class="language-js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">getControl</span>(<span class="hljs-params"><span class="hljs-keyword">from</span>, to</span>) {
  <span class="hljs-keyword">const</span> x1 = <span class="hljs-keyword">from</span>.<span class="hljs-property">x</span>;
  <span class="hljs-keyword">const</span> y1 = <span class="hljs-keyword">from</span>.<span class="hljs-property">y</span>;
  <span class="hljs-keyword">const</span> x2 = to.<span class="hljs-property">x</span>;
  <span class="hljs-keyword">const</span> y2 = to.<span class="hljs-property">y</span>;
  <span class="hljs-keyword">const</span> l = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">abs</span>(x1 - x2) * <span class="hljs-number">1.5</span>; <span class="hljs-comment">// 横坐标的差绝对值, 1.5是偏移系数,约大曲线弧度越大</span>
  <span class="hljs-keyword">const</span> L = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">sqrt</span>((x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2)); <span class="hljs-comment">// 起始点与终点的直线距离</span>
  <span class="hljs-keyword">const</span> a = (<span class="hljs-title class_">Math</span>.<span class="hljs-title function_">abs</span>(x1 - x2) * l) / L; <span class="hljs-comment">// 根据相似三角形计算出来的中间变量</span>
  <span class="hljs-keyword">const</span> b = (<span class="hljs-title class_">Math</span>.<span class="hljs-title function_">abs</span>(y1 - y2) * l) / L; <span class="hljs-comment">// 根据相似三角形计算出来的中间变量</span>
  <span class="hljs-keyword">const</span> midx = (x1 + x2) / <span class="hljs-number">2</span>; <span class="hljs-comment">// 中点横坐标</span>
  <span class="hljs-keyword">const</span> midy = (y1 + y2) / <span class="hljs-number">2</span>; <span class="hljs-comment">// 中点纵坐标</span>
  <span class="hljs-keyword">let</span> control; <span class="hljs-comment">// 二次贝塞尔曲线控制点</span>
  <span class="hljs-keyword">if</span> (x2 &gt; x1) {
    <span class="hljs-comment">// 如果起点做终点右测,则曲线向左斜</span>
    control = { <span class="hljs-attr">x</span>: midx - b, <span class="hljs-attr">y</span>: midy + a };
  } <span class="hljs-keyword">else</span> {
    <span class="hljs-comment">// 如果起点做终点左测,则曲线向右斜</span>
    control = { <span class="hljs-attr">x</span>: midx + b, <span class="hljs-attr">y</span>: midy + a };
  }
  <span class="hljs-keyword">return</span> control;
}
</code></pre><p>计算出了控制点就可以构建 svg 了</p><pre><code class="language-js"><span class="hljs-keyword">const</span> path = <span class="hljs-string">`M<span class="hljs-subst">${<span class="hljs-keyword">from</span>.x}</span> <span class="hljs-subst">${<span class="hljs-keyword">from</span>.y}</span> Q <span class="hljs-subst">${control.x}</span> <span class="hljs-subst">${control.y}</span> <span class="hljs-subst">${to.x}</span> <span class="hljs-subst">${to.y}</span>`</span>;
<span class="hljs-keyword">const</span> pathEl = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">createElementNS</span>(<span class="hljs-string">&quot;http://www.w3.org/2000/svg&quot;</span>, <span class="hljs-string">&quot;path&quot;</span>);
pathEl.<span class="hljs-title function_">setAttribute</span>(<span class="hljs-string">&quot;d&quot;</span>, path);
</code></pre><p>路径出来，再根据动效老师给的动画时间 duration，效果就实现了！</p><p>仔细看动效设计，元素在移动的过程中，自身的大小和旋转角度都在改变，接下来解决这个问题。</p><h1 id="解决元素大小和角度变化的问题">解决元素大小和角度变化的问题</h1><p>大小是时间的函数，动效老师给了起始的大小 0.4，中间的大小 1，最后的大小 0.3。将变化曲线标识在坐标轴上就是这样。 <img alt="时间-大小函数" src="https://zhangxuekang.github.io/src/blog/path-animation/f3.jpeg" width="50%"> 变化函数分为两段，每段线段都知道两个端点坐标，数学老师告诉我，这些条件可以求出函数表达式，两段就是两个式子，最后求出是</p><pre><code class="language-js"><span class="hljs-keyword">if</span> (t &lt; <span class="hljs-number">0.5</span>) {
  <span class="hljs-comment">// 两个坐标点(0,startScale) (0.5,midScale) 求scale对t的函数</span>
  scale = (midScale - startScale) * <span class="hljs-number">2</span> * t + startScale;
} <span class="hljs-keyword">else</span> {
  <span class="hljs-comment">// 两个坐标点(0.5,midScale) (1,endScale) 求scale对t的函数</span>
  scale = <span class="hljs-number">2</span> * (endScale - midScale) * t + <span class="hljs-number">2</span> * midScale - endScale;
}
</code></pre><p>将 scale 的变化考虑进去</p><pre><code class="language-js">$e.<span class="hljs-property">style</span>.<span class="hljs-property">transform</span> = <span class="hljs-string">`translate(<span class="hljs-subst">${curPosition.x}</span>px, <span class="hljs-subst">${curPosition.y}</span>px scale(<span class="hljs-subst">${scale}</span>))`</span>;
</code></pre><p>剩下的就是旋转角度了，元素的长轴永远是沿着曲线的切线，也就是旋转角度和当时的切线斜率是一致的。如何求曲线的切线？</p><p><img alt="切线斜率" src="https://zhangxuekang.github.io/src/blog/path-animation/f4.jpeg"> 几何学上，曲线的<strong>割线</strong>无限短时，就是曲线的<strong>切线</strong>。这就将切线问题转化为割线问题，如果我们记录元素移动过程中相邻的两个位置点，根据这两个点求割线的斜率，就接近于真实的切线斜率。</p><pre><code class="language-js"><span class="hljs-keyword">let</span> lastPosition = { <span class="hljs-attr">x</span>: <span class="hljs-keyword">from</span>.<span class="hljs-property">x</span>, <span class="hljs-attr">y</span>: <span class="hljs-keyword">from</span>.<span class="hljs-property">y</span> }; <span class="hljs-comment">// 记录上一个位置点</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">step</span>(<span class="hljs-params"></span>) {
  ····
  curPosition = pathEl.<span class="hljs-title function_">getPointAtLength</span>(progress); <span class="hljs-comment">// 当前位置点的坐标</span>
  <span class="hljs-keyword">const</span> rotate = <span class="hljs-title function_">getRotate</span>(lastPosition, curPosition); <span class="hljs-comment">// 获取当前方向角度</span>
  <span class="hljs-comment">// 将位置,角度和大小作用到飞点上</span>
  $e.<span class="hljs-property">style</span>.<span class="hljs-property">transform</span> = <span class="hljs-string">`translate(<span class="hljs-subst">${x}</span>px, <span class="hljs-subst">${y}</span>px) rotate(<span class="hljs-subst">${rotate}</span>deg) scale(<span class="hljs-subst">${scale}</span>)`</span>;
  lastPosition = curPosition;
  ···
}
<span class="hljs-comment">// 计算切线斜率</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">getRotate</span>(<span class="hljs-params">lastPos, thisPos</span>) {
  <span class="hljs-keyword">const</span> x1 = lastPos.<span class="hljs-property">x</span>;
  <span class="hljs-keyword">const</span> y1 = lastPos.<span class="hljs-property">y</span>;
  <span class="hljs-keyword">const</span> x2 = thisPos.<span class="hljs-property">x</span>;
  <span class="hljs-keyword">const</span> y2 = thisPos.<span class="hljs-property">y</span>;
  <span class="hljs-keyword">const</span> tan_deg = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">abs</span>(x1 - x2) / <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">abs</span>(y1 - y2);  <span class="hljs-comment">// 正切值tan/tg</span>
  <span class="hljs-keyword">const</span> deg = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">atan</span>(tan_deg); <span class="hljs-comment">// 反函数求角度</span>
  <span class="hljs-keyword">return</span> ((x2 - x1 &gt; <span class="hljs-number">0</span> ? deg : -deg) * <span class="hljs-number">180</span>) / <span class="hljs-title class_">Math</span>.<span class="hljs-property">PI</span> || <span class="hljs-number">0</span>;
}
</code></pre><p>至此，这次动画效果完整实现了出来。</p><h1 id="总结">总结</h1><p>这次需求涉及到的数学知识很多，如何拟合曲线、路程时间速度计算、相似三角形、求函数表达式（二元一次方程组求解）、求曲线切线斜率。不过还好，都是初高中学到的，还不算超纲。</p><p>掌握 SVGPathElement 接口的两个方法 getTotalLength()、getPointAtLength()，能实现无比复杂的移动动画。</p></section></div><div id="footer_wrap" class="outer"><footer class="inner"><p class="update-time">更新于 2021-10-10</p><p class="copyright">zhangxk-notes maintained by <a href="https://github.com/zhangxuekang">zhangxuekang</a></p></footer></div></body></html>
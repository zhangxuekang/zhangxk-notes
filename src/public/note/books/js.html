<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><meta name="keywords" content="zhangxuekang,zhangxk"><link rel="shortcut icon" href="https://zhangxuekang.github.io/src/zhangxk.ico" type="image/x-icon"><title>zhangxk-zhangxk-notes</title><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.2.0/styles/default.min.css"><style>a,abbr,acronym,address,applet,article,aside,audio,b,big,blockquote,body,canvas,caption,center,cite,code,dd,del,details,dfn,div,dl,dt,em,embed,fieldset,figcaption,figure,footer,form,h1,h2,h3,h4,h5,h6,header,hgroup,html,i,iframe,img,ins,kbd,label,legend,li,mark,menu,nav,object,ol,output,p,pre,q,ruby,s,samp,section,small,span,strike,strong,sub,summary,sup,table,tbody,td,tfoot,th,thead,time,tr,tt,u,ul,var,video{margin:0;padding:0;border:0;font:inherit;vertical-align:baseline}article,aside,details,figcaption,figure,footer,header,hgroup,menu,nav,section{display:block}ol,ul{list-style:none}table{border-collapse:collapse;border-spacing:0}body{box-sizing:border-box;color:#373737;background:#212121;font-size:16px;font-family:"Myriad Pro",Calibri,Helvetica,Arial,sans-serif;line-height:1.5;-webkit-font-smoothing:antialiased}h1,h2,h3,h4,h5,h6{margin:10px 0;font-weight:700;color:#222;font-family:"Lucida Grande",Calibri,Helvetica,Arial,sans-serif;letter-spacing:-1px}h1{font-size:36px;font-weight:700}h2{margin-bottom:20px;font-size:32px;border-bottom:1px dashed #dadada}h3{font-size:24px}h4{font-size:21px}h5{font-size:18px}h6{font-size:16px}p{margin:10px 0 15px 0}footer p{color:#f2f2f2}a{text-decoration:none;color:#0f79d0;text-shadow:none;transition:color .5s ease;transition:text-shadow .5s ease;-webkit-transition:color .5s ease;-webkit-transition:text-shadow .5s ease;-moz-transition:color .5s ease;-moz-transition:text-shadow .5s ease;-o-transition:color .5s ease;-o-transition:text-shadow .5s ease;-ms-transition:color .5s ease;-ms-transition:text-shadow .5s ease}a:focus,a:hover{text-decoration:underline}footer a{color:#f2f2f2;text-decoration:underline}cite,em{font-style:italic}strong{font-weight:700}img{position:relative;margin:0 auto;max-width:739px;padding:5px;margin:10px 0 10px 0;border:1px solid #ebebeb;box-shadow:0 0 5px #ebebeb;-webkit-box-shadow:0 0 5px #ebebeb;-moz-box-shadow:0 0 5px #ebebeb;-o-box-shadow:0 0 5px #ebebeb;-ms-box-shadow:0 0 5px #ebebeb}p img{display:inline;margin:0;padding:0;vertical-align:middle;text-align:center;border:none}code,pre{color:#222;font-family:Monaco,"Bitstream Vera Sans Mono","Lucida Console",Terminal,monospace;font-size:.875em;border-radius:2px;-moz-border-radius:2px;-webkit-border-radius:2px}pre{padding:10px;box-shadow:0 0 10px rgba(0,0,0,.1);overflow:auto}code{padding:3px;margin:0 3px;box-shadow:0 0 10px rgba(0,0,0,.1)}pre code{display:block;box-shadow:none}blockquote{color:#666;margin-bottom:20px;padding:0 0 0 20px;border-left:3px solid #bbb}dl,ol,ul{margin-bottom:15px}ul{list-style-position:inside;list-style:disc;padding-left:20px}ol{list-style-position:inside;list-style:decimal;padding-left:20px}dl dt{font-weight:700}dl dd{padding-left:20px;font-style:italic}dl p{padding-left:20px;font-style:italic}hr{height:1px;margin-bottom:5px;border:none;background:url(../images/bg_hr.png) repeat-x center}table{border:1px solid #373737;margin-bottom:20px;margin-top:10px;text-align:left}th{font-family:"Lucida Grande","Helvetica Neue",Helvetica,Arial,sans-serif;padding:10px;background:#373737;color:#fff}td{padding:10px;border:1px solid #373737}form{background:#f2f2f2;padding:20px}kbd{background-color:#fafbfc;border:1px solid #c6cbd1;border-bottom-color:#959da5;border-radius:3px;box-shadow:inset 0 -1px 0 #959da5;color:#444d56;display:inline-block;font-size:11px;line-height:11px;padding:3px 5px;vertical-align:middle}.outer{width:100%}.inner{position:relative;max-width:640px;padding:20px 10px;margin:0 auto}#header_wrap{background:#212121;background:-moz-linear-gradient(top,#373737,#212121);background:-webkit-linear-gradient(top,#373737,#212121);background:-ms-linear-gradient(top,#373737,#212121);background:-o-linear-gradient(top,#373737,#212121);background:linear-gradient(to top,#373737,#212121)}#header_wrap .inner{padding:50px 10px 30px 10px}#project_title{margin:0;color:#fff;font-size:42px;font-weight:700;text-shadow:#111 0 0 10px}#project_tagline{color:#222;font-weight:300;background:0 0;text-shadow:#111 0 0 10px;border-bottom:none}#project_tagline span{display:inline-block;height:33px;font-size:13px;line-height:33px;overflow:hidden;margin-bottom:10px;margin-right:10px;padding:0 12px;border-radius:100px;background:rgba(242,242,242,.5)}#project_time{color:#fff;text-shadow:#111 0 0 10px}#main_content_wrap{background:#f2f2f2;border-top:1px solid #111;border-bottom:1px solid #111}#main_content{padding-top:40px}#footer_wrap{background:#212121}@media screen and (max-width:992px){img{max-width:100%}}@media screen and (max-width:480px){body{font-size:14px}#downloads{display:none}.inner{min-width:320px;max-width:480px}#project_title{font-size:32px}h1{font-size:28px}h2{font-size:24px}h3{font-size:21px}h4{font-size:18px}h5{font-size:14px}h6{font-size:12px}code,pre{font-size:11px}}@media screen and (max-width:320px){body{font-size:14px}#downloads{display:none}.inner{min-width:240px;max-width:320px}#project_title{font-size:28px}h1{font-size:24px}h2{font-size:21px}h3{font-size:18px}h4{font-size:16px}h5{font-size:14px}h6{font-size:12px}code,pre{min-width:240px;max-width:320px;font-size:11px}}#header_wrap{width:100%;background-size:cover;background-image:url(https://source.unsplash.com/1200x180/?nature,water)}pre{white-space:pre;word-wrap:normal;background:#282936}pre code{color:#e9e9f4;background:#262822}.cnblogs-markdown .hljs{display:block;overflow:auto;padding:1.3em 2em!important;font-size:16px!important;background:#272822!important;color:#fff;max-height:700px}.hljs,.hljs-subst,.hljs-tag{color:#f8f8f2}.hljs-emphasis,.hljs-strong{color:#a8a8a2}.hljs-bullet,.hljs-link,.hljs-literal,.hljs-number,.hljs-quote,.hljs-regexp{color:#ae81ff}.hljs-code,.hljs-section,.hljs-selector-class,.hljs-title{color:#a6e22e}.hljs-strong{font-weight:700}.hljs-emphasis{font-style:italic}.hljs-attr,.hljs-keyword,.hljs-name,.hljs-selector-tag{color:#f92672}.hljs-attribute,.hljs-symbol{color:#66d9ef}.hljs-class .hljs-title,.hljs-params{color:#f8f8f2}.hljs-addition,.hljs-built_in,.hljs-builtin-name,.hljs-selector-attr,.hljs-selector-id,.hljs-selector-pseudo,.hljs-string,.hljs-template-variable,.hljs-type,.hljs-variable{color:#e6db74}.hljs-comment,.hljs-deletion,.hljs-meta{color:#75715e}p>code{color:#c7254e;border:none!important;font-size:1em!important;background-color:#f9f2f4!important;font-weight:500;font-family:Monaco,"Bitstream Vera Sans Mono","Lucida Console",Terminal!important}</style></head><body><div id="header_wrap" class="outer"><header class="inner"><h1 id="project_title">zhangxk-notes</h1><p id="project_tagline"></p><p id="project_time"></p></header></div><div id="main_content_wrap" class="outer"><section id="main_content" class="inner"><p>声明提升，相同的函数会覆盖上一个函数，并且函数声明优先于变量声明。</p><hr><p>箭头函数其实是没有 this 的，this 在箭头函数里就是个普通变量，取的是最近的非箭头函数环境的 this 值。</p><hr><p>setTimeout 和 setInterval 都返回一个整数，这个整数就是 id 值，这个值是两者公用的</p><p>返回值 timeoutID 是一个正整数，表示定时器的编号。这个值可以传递给 clearTimeout()来取消该定时器。需要注意的是 setTimeout()和 setInterval()共用一个编号池，技术上，clearTimeout()和 clearInterval() 可以互换。但是，为了避免混淆，不要混用取消定时函数。</p><hr><h2 id="事件循环">事件循环</h2><ol><li>首先 js 是<strong>单线程</strong>运行的，在代码执行的时候，通过将不同函数的<strong>执行上下文</strong>压入<strong>执行栈</strong>中来保证代码的有序执行。</li><li>在执行<strong>同步代码</strong>的时候，如果遇到了<strong>异步事件</strong>，js 引擎并不会一直等待其返回结果，而是会将这个事件<strong>挂起</strong>，继续执行执行栈中的其他任务</li><li>当<strong>同步事件</strong>执行完毕后，再将异步事件对应的回调加入到与<strong>当前执行栈中不同的另一个任务队列</strong>中等待执行。</li><li>任务队列可以分为<strong>宏任务</strong>队列和<strong>微任务</strong>队列，当前执行栈中的事件执行完毕后，js 引擎首先会判断微任务对列中是否有任务可以执行，如果有就将微任务队首的事件压入栈中执行。</li><li>当微任务对列中的任务都执行完成后再去判断宏任务对列中的任务。</li></ol><p>宏任务是由宿主发起的，而微任务由 JavaScript 自身发起。</p><p>在 ES3 以及以前的版本中，JavaScript 本身没有发起异步请求的能力，也就没有微任务的存在。在 ES5 之后，JavaScript 引入了 Promise，这样，不需要浏览器，JavaScript 引擎自身也能够发起异步任务了。</p><p>Node 里面对 setTimeout 的特殊处理：setTimeout(fn, 0)会被强制改为 setTimeout(fn, 1)。</p><p>HTML 5 里面 setTimeout 最小的时间限制是 4ms</p><p>nextTick 和 Promise 同时出现时，肯定是 nextTick 先执行，原因是 nextTick 的队列比 Promise 队列优先级更高。</p><p>执行每个宏任务之前都要检查下微任务队列是否有任务，如果有，优先执行微任务队列。</p><ol><li>一个 Event Loop 可以有一个或多个事件队列，但是只有一个微任务队列。</li><li>微任务队列全部执行完会重新渲染一次</li><li>每个宏任务执行完都会重新渲染一次</li><li>requestAnimationFrame 处于渲染阶段，不在微任务队列，也不在宏任务队列</li></ol><h3 id="宏任务">宏任务:</h3><ol><li>script (可以理解为外层同步代码)</li><li>setTimeout/setInterval</li><li>setImmediate(Node.js)</li><li>I/O</li><li>UI 事件</li><li>postMessage</li></ol><h3 id="微任务">微任务:</h3><ol><li>Promise</li><li>process.nextTick(Node.js)</li><li>Object.observe</li><li>MutaionObserver</li></ol><h3 id="nodejs-的-event-loop">Node.js 的 Event Loop:</h3><ol><li>timers: 执行 setTimeout 和 setInterval 的回调</li><li>pending callbacks: 执行延迟到下一个循环迭代的 I/O 回调</li><li>idle, prepare: 仅系统内部使用</li><li>poll: 检索新的 I/O 事件;执行与 I/O 相关的回调。事实上除了其他几个阶段处理的事情，其他几乎所有的异步都在这个阶段处理。</li><li>check: setImmediate 在这里执行</li><li>close callbacks: 一些关闭的回调函数，如：socket.on(&#39;close&#39;, ...)</li></ol><h3 id="setimmediate-vs-settimeout">setImmediate VS setTimeout</h3><p><strong>在一个异步流程</strong>里，setImmediate 会比定时器先执行</p><pre><code class="language-js"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;outer&quot;</span>);

<span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> {
  <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;setTimeout&quot;</span>);
  }, <span class="hljs-number">0</span>);
  <span class="hljs-title function_">setImmediate</span>(<span class="hljs-function">() =&gt;</span> {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;setImmediate&quot;</span>);
  });
}, <span class="hljs-number">0</span>);

<span class="hljs-comment">// outer</span>
<span class="hljs-comment">// setImmediate</span>
<span class="hljs-comment">// setTimeout</span>
</code></pre><ol><li>外层是一个 setTimeout，所以执行他的回调的时候已经在 timers 阶段了</li><li>处理里面的 setTimeout，因为本次循环的 timers 正在执行，所以他的回调其实加到了下个 timers 阶段</li><li>处理里面的 setImmediate，将它的回调加入 check 阶段的队列</li><li>外层 timers 阶段执行完，进入 pending callbacks，idle, prepare，poll，这几个队列都是空的，所以继续往下</li><li>到了 check 阶段，发现了 setImmediate 的回调，拿出来执行</li><li>然后是 close callbacks，队列是空的，跳过</li><li>又是 timers 阶段，执行我们的 console</li></ol><p>写在最外层:</p><pre><code class="language-js"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;outer&quot;</span>);

<span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> {
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;setTimeout&quot;</span>);
}, <span class="hljs-number">0</span>);

<span class="hljs-title function_">setImmediate</span>(<span class="hljs-function">() =&gt;</span> {
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;setImmediate&quot;</span>);
});
</code></pre><p>// outer // setTimeout 和 setImmediate 顺序不定</p><ol><li>外层同步代码一次性全部执行完，遇到异步 API 就塞到对应的阶段</li><li>遇到 setTimeout，虽然设置的是 0 毫秒触发，但是被 node.js 强制改为 1 毫秒，塞入 times 阶段</li><li>遇到 setImmediate 塞入 check 阶段</li><li>同步代码执行完毕，进入 Event Loop</li><li>先进入 times 阶段，检查当前时间过去了 1 毫秒没有，如果过了 1 毫秒，满足 setTimeout 条件，执行回调，如果没过 1 毫秒，跳过</li><li>跳过空的阶段，进入 check 阶段，执行 setImmediate 回调</li></ol><hr><h2 id="垃圾回收">垃圾回收</h2><h3 id="引用计数">引用计数</h3><p>此算法把“对象是否不再需要”简化定义为“对象有没有其他对象引用到它”。如果没有引用指向该对象（零引用），对象将被垃圾回收机制回收。</p><p>限制：无法处理循环引用的事例。</p><h3 id="标记清除">标记清除</h3><p>这个算法把“对象是否不再需要”简化定义为“对象是否可以获得”。这个算法假定设置一个叫做根（root）的对象（在 Javascript 里，根是全局对象）。垃圾回收器将定期从根开始，找所有从根开始引用的对象，然后找这些对象引用的对象……从根开始，垃圾回收器将找到所有可以获得的对象和收集所有不能获得的对象。</p><p>从 2012 年起，所有现代浏览器都使用了标记-清除垃圾回收算法。</p><p>限制: 那些无法从根对象查询到的对象都将被清除</p><p>尽管这是一个限制，但实践中我们很少会碰到类似的情况，所以开发者不太会去关心垃圾回收机制。</p><h2 id="深浅拷贝">深浅拷贝</h2><h3 id="浅拷贝">浅拷贝</h3><p>Array 中存在一些可以实现浅拷贝的方法：slice、concat...</p><p>一般的对象可以用 Object 的方法：assign</p><p>也可以使用 ES6 提供的新的语法(对象和数组都可以使用)：&quot;...&quot;</p><h3 id="深拷贝">深拷贝</h3><p>parse、stringify <code>var newObj = JSON.parse(JSON.stringify(obj));</code> 。该方法会忽略 undefined、任意的函数、symbol 值，因为 JSON 不支持这些数据类型。</p><p>递归实现(极度简单)：</p><pre><code class="language-js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">deepClone</span>(<span class="hljs-params">obj</span>) {
  <span class="hljs-keyword">if</span> (obj &amp;&amp; <span class="hljs-keyword">typeof</span> obj === <span class="hljs-string">&quot;object&quot;</span>) {
    <span class="hljs-keyword">const</span> result = <span class="hljs-title class_">Array</span>.<span class="hljs-title function_">isArray</span>(obj) ? [] : {};
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> key <span class="hljs-keyword">in</span> obj) {
      <span class="hljs-keyword">if</span> (obj.<span class="hljs-title function_">hasOwnProperty</span>(key)) {
        <span class="hljs-keyword">if</span> (obj[key] &amp;&amp; <span class="hljs-keyword">typeof</span> obj[key] === <span class="hljs-string">&quot;object&quot;</span>) {
          result[key] = <span class="hljs-title function_">deepClone</span>(obj[key]);
        } <span class="hljs-keyword">else</span> {
          result[key] = obj[key];
        }
      }
    }
    <span class="hljs-keyword">return</span> result;
  } <span class="hljs-keyword">else</span> {
    <span class="hljs-keyword">return</span> obj;
  }
}
</code></pre><h2 id="this-的指向">this 的指向</h2><ol><li>用 new 调用函数， this 指向新创建的对象。</li><li>使用 call，apply（bind）调用函数， this 指向绑定的的对象。</li><li>函数作为某对象的属性调用， this 指向这个对象。</li><li>其他情况下， this 指向全局对象（严格模式下指向 undefined）。</li></ol><p>补充： 如果第二条规则绑定的是 null 或者 undefined， 则执行第四条规则； 1-4 条规则优先级递减。</p><h2 id="new-操作符做的事情">new 操作符做的事情</h2><ol><li>新生成一个新对象</li><li>链接到原型</li><li>绑定 <code>this</code></li><li>返回新对象</li></ol></section></div><div id="footer_wrap" class="outer"><footer class="inner"><p class="update-time">更新于 2021-10-08</p><p class="copyright">zhangxk-notes maintained by <a href="https://github.com/zhangxuekang">zhangxuekang</a></p></footer></div></body></html>
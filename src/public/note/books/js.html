<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><meta name="keywords" content="zhangxuekang,zhangxk"><link rel="shortcut icon" href="https://zhangxuekang.github.io/src/zhangxk.ico" type="image/x-icon"><title>zhangxk-zhangxk-notes</title><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.2.0/styles/default.min.css"><style>a,abbr,acronym,address,applet,article,aside,audio,b,big,blockquote,body,canvas,caption,center,cite,code,dd,del,details,dfn,div,dl,dt,em,embed,fieldset,figcaption,figure,footer,form,h1,h2,h3,h4,h5,h6,header,hgroup,html,i,iframe,img,ins,kbd,label,legend,li,mark,menu,nav,object,ol,output,p,pre,q,ruby,s,samp,section,small,span,strike,strong,sub,summary,sup,table,tbody,td,tfoot,th,thead,time,tr,tt,u,ul,var,video{margin:0;padding:0;border:0;font:inherit;vertical-align:baseline}article,aside,details,figcaption,figure,footer,header,hgroup,menu,nav,section{display:block}ol,ul{list-style:none}table{border-collapse:collapse;border-spacing:0}body{box-sizing:border-box;color:#373737;background:#212121;font-size:16px;font-family:"Myriad Pro",Calibri,Helvetica,Arial,sans-serif;line-height:1.5;-webkit-font-smoothing:antialiased}h1,h2,h3,h4,h5,h6{margin:10px 0;font-weight:700;color:#222;font-family:"Lucida Grande",Calibri,Helvetica,Arial,sans-serif;letter-spacing:-1px}h1{font-size:36px;font-weight:700}h2{margin-bottom:20px;font-size:32px;border-bottom:1px dashed #dadada}h3{font-size:24px}h4{font-size:21px}h5{font-size:18px}h6{font-size:16px}p{margin:10px 0 15px 0}footer p{color:#f2f2f2}a{text-decoration:none;color:#0f79d0;text-shadow:none;transition:color .5s ease;transition:text-shadow .5s ease;-webkit-transition:color .5s ease;-webkit-transition:text-shadow .5s ease;-moz-transition:color .5s ease;-moz-transition:text-shadow .5s ease;-o-transition:color .5s ease;-o-transition:text-shadow .5s ease;-ms-transition:color .5s ease;-ms-transition:text-shadow .5s ease}a:focus,a:hover{text-decoration:underline}footer a{color:#f2f2f2;text-decoration:underline}cite,em{font-style:italic}strong{font-weight:700}img{position:relative;margin:0 auto;max-width:739px;padding:5px;margin:10px 0 10px 0;border:1px solid #ebebeb;box-shadow:0 0 5px #ebebeb;-webkit-box-shadow:0 0 5px #ebebeb;-moz-box-shadow:0 0 5px #ebebeb;-o-box-shadow:0 0 5px #ebebeb;-ms-box-shadow:0 0 5px #ebebeb}p img{display:inline;margin:0;padding:0;vertical-align:middle;text-align:center;border:none}code,pre{color:#222;font-family:Monaco,"Bitstream Vera Sans Mono","Lucida Console",Terminal,monospace;font-size:.875em;border-radius:2px;-moz-border-radius:2px;-webkit-border-radius:2px}pre{padding:10px;box-shadow:0 0 10px rgba(0,0,0,.1);overflow:auto}code{padding:3px;margin:0 3px;box-shadow:0 0 10px rgba(0,0,0,.1)}pre code{display:block;box-shadow:none}blockquote{color:#666;margin-bottom:20px;padding:0 0 0 20px;border-left:3px solid #bbb}dl,ol,ul{margin-bottom:15px}ul{list-style-position:inside;list-style:disc;padding-left:20px}ol{list-style-position:inside;list-style:decimal;padding-left:20px}dl dt{font-weight:700}dl dd{padding-left:20px;font-style:italic}dl p{padding-left:20px;font-style:italic}hr{height:1px;margin-bottom:5px;border:none;background:url(../images/bg_hr.png) repeat-x center}table{border:1px solid #373737;margin-bottom:20px;margin-top:10px;text-align:left}th{font-family:"Lucida Grande","Helvetica Neue",Helvetica,Arial,sans-serif;padding:10px;background:#373737;color:#fff}td{padding:10px;border:1px solid #373737}form{background:#f2f2f2;padding:20px}kbd{background-color:#fafbfc;border:1px solid #c6cbd1;border-bottom-color:#959da5;border-radius:3px;box-shadow:inset 0 -1px 0 #959da5;color:#444d56;display:inline-block;font-size:11px;line-height:11px;padding:3px 5px;vertical-align:middle}.outer{width:100%}.inner{position:relative;max-width:640px;padding:20px 10px;margin:0 auto}#header_wrap{background:#212121;background:-moz-linear-gradient(top,#373737,#212121);background:-webkit-linear-gradient(top,#373737,#212121);background:-ms-linear-gradient(top,#373737,#212121);background:-o-linear-gradient(top,#373737,#212121);background:linear-gradient(to top,#373737,#212121)}#header_wrap .inner{padding:50px 10px 30px 10px}#project_title{margin:0;color:#fff;font-size:42px;font-weight:700;text-shadow:#111 0 0 10px}#project_tagline{color:#222;font-weight:300;background:0 0;text-shadow:#111 0 0 10px;border-bottom:none}#project_tagline span{display:inline-block;height:33px;font-size:13px;line-height:33px;overflow:hidden;margin-bottom:10px;margin-right:10px;padding:0 12px;border-radius:100px;background:rgba(242,242,242,.5)}#project_time{color:#fff;text-shadow:#111 0 0 10px}#main_content_wrap{background:#f2f2f2;border-bottom:1px solid #111}#main_content{padding-top:40px}#footer_wrap{background:#212121}@media screen and (max-width:992px){img{max-width:100%}}@media screen and (max-width:480px){body{font-size:14px}#downloads{display:none}.inner{min-width:320px;max-width:480px}#project_title{font-size:32px}h1{font-size:28px}h2{font-size:24px}h3{font-size:21px}h4{font-size:18px}h5{font-size:14px}h6{font-size:12px}code,pre{font-size:11px}}@media screen and (max-width:320px){body{font-size:14px}#downloads{display:none}.inner{min-width:240px;max-width:320px}#project_title{font-size:28px}h1{font-size:24px}h2{font-size:21px}h3{font-size:18px}h4{font-size:16px}h5{font-size:14px}h6{font-size:12px}code,pre{min-width:240px;max-width:320px;font-size:11px}}#header_wrap{width:100%;background-size:cover;background-image:url(https://source.unsplash.com/1200x180/?nature,water)}pre{white-space:pre;word-wrap:normal;background:#282936}pre code{color:#e9e9f4;background:#262822}.cnblogs-markdown .hljs{display:block;overflow:auto;padding:1.3em 2em!important;font-size:16px!important;background:#272822!important;color:#fff;max-height:700px}.hljs,.hljs-subst,.hljs-tag{color:#f8f8f2}.hljs-emphasis,.hljs-strong{color:#a8a8a2}.hljs-bullet,.hljs-link,.hljs-literal,.hljs-number,.hljs-quote,.hljs-regexp{color:#ae81ff}.hljs-code,.hljs-section,.hljs-selector-class,.hljs-title{color:#a6e22e}.hljs-strong{font-weight:700}.hljs-emphasis{font-style:italic}.hljs-attr,.hljs-keyword,.hljs-name,.hljs-selector-tag{color:#f92672}.hljs-attribute,.hljs-symbol{color:#66d9ef}.hljs-class .hljs-title,.hljs-params{color:#f8f8f2}.hljs-addition,.hljs-built_in,.hljs-builtin-name,.hljs-selector-attr,.hljs-selector-id,.hljs-selector-pseudo,.hljs-string,.hljs-template-variable,.hljs-type,.hljs-variable{color:#e6db74}.hljs-comment,.hljs-deletion,.hljs-meta{color:#75715e}li>code,p>code{color:#c7254e;border:none!important;font-size:1em!important;background-color:#f9f2f4!important;font-weight:500;font-family:Monaco,"Bitstream Vera Sans Mono","Lucida Console",Terminal!important}</style></head><body><div id="header_wrap" class="outer"><header class="inner"><h1 id="project_title">zhangxk-notes</h1><p id="project_tagline"></p><p id="project_time"></p></header></div><div id="main_content_wrap" class="outer"><section id="main_content" class="inner"><p>声明提升，相同的函数会覆盖上一个函数，并且函数声明优先于变量声明。</p><hr><p>箭头函数其实是没有 this 的，this 在箭头函数里就是个普通变量，取的是最近的非箭头函数环境的 this 值。</p><hr><p>setTimeout 和 setInterval 都返回一个整数，这个整数就是 id 值，这个值是两者公用的</p><p>返回值 timeoutID 是一个正整数，表示定时器的编号。这个值可以传递给 clearTimeout()来取消该定时器。需要注意的是 setTimeout()和 setInterval()共用一个编号池，技术上，clearTimeout()和 clearInterval() 可以互换。但是，为了避免混淆，不要混用取消定时函数。</p><hr><h2 id="事件循环">事件循环</h2><ol><li>首先 js 是<strong>单线程</strong>运行的，在代码执行的时候，通过将不同函数的<strong>执行上下文</strong>压入<strong>执行栈</strong>中来保证代码的有序执行。</li><li>在执行<strong>同步代码</strong>的时候，如果遇到了<strong>异步事件</strong>，js 引擎并不会一直等待其返回结果，而是会将这个事件<strong>挂起</strong>，继续执行执行栈中的其他任务</li><li>当<strong>同步事件</strong>执行完毕后，再将异步事件对应的回调加入到与<strong>当前执行栈中不同的另一个任务队列</strong>中等待执行。</li><li>任务队列可以分为<strong>宏任务</strong>队列和<strong>微任务</strong>队列，当前执行栈中的事件执行完毕后，js 引擎首先会判断微任务对列中是否有任务可以执行，如果有就将微任务队首的事件压入栈中执行。</li><li>当微任务对列中的任务都执行完成后再去判断宏任务对列中的任务。</li></ol><p>宏任务是由宿主发起的，而微任务由 JavaScript 自身发起。</p><p>在 ES3 以及以前的版本中，JavaScript 本身没有发起异步请求的能力，也就没有微任务的存在。在 ES5 之后，JavaScript 引入了 Promise，这样，不需要浏览器，JavaScript 引擎自身也能够发起异步任务了。</p><p>Node 里面对 setTimeout 的特殊处理：setTimeout(fn, 0)会被强制改为 setTimeout(fn, 1)。</p><p>HTML 5 里面 setTimeout 最小的时间限制是 4ms</p><p>nextTick 和 Promise 同时出现时，肯定是 nextTick 先执行，原因是 nextTick 的队列比 Promise 队列优先级更高。</p><p>执行每个宏任务之前都要检查下微任务队列是否有任务，如果有，优先执行微任务队列。</p><ol><li><p>event loop 每轮的 task 执行完成后，<strong>不一定</strong>都会伴随页面的更新渲染；</p><ul><li>是否需要进行更新渲染，会根据浏览器刷新率以及页面性能或是否后台运行等因素判断的。</li><li>大多数显示器的刷新频率是 60Hz，浏览器也会尽量保持 60Hz 的刷新率运行，也就是 16.7ms 刷新一帧，所以如果定时器的延迟时间小于 16.7ms 时，可能就不会刷新。</li><li>task 循环调用时，不会阻塞页面的渲染。</li><li>循环调用微任务时，就会阻塞页面的渲染。</li></ul></li><li><p>task、microtask 和 RAF 对应队列的执行：</p><ol><li>每一轮 loop 对应一个 task；</li><li>microtask 队列则会在每一轮 loop 中全部执行完毕（包含嵌套产生的 microtask）；</li><li>RAF 队列中当前 task 中产生的 RAF 会在每一轮 loop 执行完毕，嵌套的 RAF 则在下一帧之前执行。</li></ol></li><li><p>RAF 回调的执行与 task 和 microtask 无关，而是与浏览器是否渲染相关联的；</p><ol><li>渲染前会执行 resize 和 scroll 事件回调</li><li>渲染前执行 RAF</li></ol></li></ol><h3 id="宏任务">宏任务:</h3><ol><li>script (可以理解为外层同步代码)</li><li>setTimeout/setInterval</li><li>setImmediate(Node.js)</li><li>I/O</li><li>UI 事件</li><li>postMessage</li></ol><h3 id="微任务">微任务:</h3><ol><li>Promise</li><li>process.nextTick(Node.js)</li><li>Object.observe</li><li>MutaionObserver</li></ol><h3 id="nodejs-的-event-loop">Node.js 的 Event Loop:</h3><ol><li>timers: 执行 setTimeout 和 setInterval 的回调</li><li>pending callbacks: 执行延迟到下一个循环迭代的 I/O 回调</li><li>idle, prepare: 仅系统内部使用</li><li>poll: 检索新的 I/O 事件;执行与 I/O 相关的回调。事实上除了其他几个阶段处理的事情，其他几乎所有的异步都在这个阶段处理。</li><li>check: setImmediate 在这里执行</li><li>close callbacks: 一些关闭的回调函数，如：socket.on(&#39;close&#39;, ...)</li></ol><h3 id="setimmediate-vs-settimeout">setImmediate VS setTimeout</h3><p><strong>在一个异步流程</strong>里，setImmediate 会比定时器先执行</p><pre><code class="language-js"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;outer&quot;</span>);

<span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> {
  <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;setTimeout&quot;</span>);
  }, <span class="hljs-number">0</span>);
  <span class="hljs-title function_">setImmediate</span>(<span class="hljs-function">() =&gt;</span> {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;setImmediate&quot;</span>);
  });
}, <span class="hljs-number">0</span>);

<span class="hljs-comment">// outer</span>
<span class="hljs-comment">// setImmediate</span>
<span class="hljs-comment">// setTimeout</span>
</code></pre><ol><li>外层是一个 setTimeout，所以执行他的回调的时候已经在 timers 阶段了</li><li>处理里面的 setTimeout，因为本次循环的 timers 正在执行，所以他的回调其实加到了下个 timers 阶段</li><li>处理里面的 setImmediate，将它的回调加入 check 阶段的队列</li><li>外层 timers 阶段执行完，进入 pending callbacks，idle, prepare，poll，这几个队列都是空的，所以继续往下</li><li>到了 check 阶段，发现了 setImmediate 的回调，拿出来执行</li><li>然后是 close callbacks，队列是空的，跳过</li><li>又是 timers 阶段，执行我们的 console</li></ol><p>写在最外层:</p><pre><code class="language-js"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;outer&quot;</span>);

<span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> {
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;setTimeout&quot;</span>);
}, <span class="hljs-number">0</span>);

<span class="hljs-title function_">setImmediate</span>(<span class="hljs-function">() =&gt;</span> {
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;setImmediate&quot;</span>);
});
</code></pre><p>// outer // setTimeout 和 setImmediate 顺序不定</p><ol><li>外层同步代码一次性全部执行完，遇到异步 API 就塞到对应的阶段</li><li>遇到 setTimeout，虽然设置的是 0 毫秒触发，但是被 node.js 强制改为 1 毫秒，塞入 times 阶段</li><li>遇到 setImmediate 塞入 check 阶段</li><li>同步代码执行完毕，进入 Event Loop</li><li>先进入 times 阶段，检查当前时间过去了 1 毫秒没有，如果过了 1 毫秒，满足 setTimeout 条件，执行回调，如果没过 1 毫秒，跳过</li><li>跳过空的阶段，进入 check 阶段，执行 setImmediate 回调</li></ol><hr><h2 id="垃圾回收">垃圾回收</h2><h3 id="引用计数">引用计数</h3><p>此算法把“对象是否不再需要”简化定义为“对象有没有其他对象引用到它”。如果没有引用指向该对象（零引用），对象将被垃圾回收机制回收。</p><p>限制：无法处理循环引用的事例。</p><h3 id="标记清除">标记清除</h3><p>这个算法把“对象是否不再需要”简化定义为“对象是否可以获得”。这个算法假定设置一个叫做根（root）的对象（在 Javascript 里，根是全局对象）。垃圾回收器将定期从根开始，找所有从根开始引用的对象，然后找这些对象引用的对象……从根开始，垃圾回收器将找到所有可以获得的对象和收集所有不能获得的对象。</p><p>从 2012 年起，所有现代浏览器都使用了标记-清除垃圾回收算法。</p><p>限制: 那些无法从根对象查询到的对象都将被清除</p><p>尽管这是一个限制，但实践中我们很少会碰到类似的情况，所以开发者不太会去关心垃圾回收机制。</p><h2 id="深浅拷贝">深浅拷贝</h2><h3 id="浅拷贝">浅拷贝</h3><p>Array 中存在一些可以实现浅拷贝的方法：slice、concat...</p><p>一般的对象可以用 Object 的方法：assign</p><p>也可以使用 ES6 提供的新的语法(对象和数组都可以使用)：&quot;...&quot;</p><h3 id="深拷贝">深拷贝</h3><p>parse、stringify <code>var newObj = JSON.parse(JSON.stringify(obj));</code> 。该方法会忽略 undefined、任意的函数、symbol 值，因为 JSON 不支持这些数据类型。</p><p>递归实现(极度简单)：</p><pre><code class="language-js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">deepClone</span>(<span class="hljs-params">obj</span>) {
  <span class="hljs-keyword">if</span> (obj &amp;&amp; <span class="hljs-keyword">typeof</span> obj === <span class="hljs-string">&quot;object&quot;</span>) {
    <span class="hljs-keyword">const</span> result = <span class="hljs-title class_">Array</span>.<span class="hljs-title function_">isArray</span>(obj) ? [] : {};
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> key <span class="hljs-keyword">in</span> obj) {
      <span class="hljs-keyword">if</span> (obj.<span class="hljs-title function_">hasOwnProperty</span>(key)) {
        <span class="hljs-keyword">if</span> (obj[key] &amp;&amp; <span class="hljs-keyword">typeof</span> obj[key] === <span class="hljs-string">&quot;object&quot;</span>) {
          result[key] = <span class="hljs-title function_">deepClone</span>(obj[key]);
        } <span class="hljs-keyword">else</span> {
          result[key] = obj[key];
        }
      }
    }
    <span class="hljs-keyword">return</span> result;
  } <span class="hljs-keyword">else</span> {
    <span class="hljs-keyword">return</span> obj;
  }
}
</code></pre><h2 id="this-的指向">this 的指向</h2><ol><li>用 new 调用函数， this 指向新创建的对象。</li><li>使用 call，apply（bind）调用函数， this 指向绑定的的对象。</li><li>函数作为某对象的属性调用， this 指向这个对象。</li><li>其他情况下， this 指向全局对象（严格模式下指向 undefined）。</li></ol><p>补充： 如果第二条规则绑定的是 null 或者 undefined， 则执行第四条规则； 1-4 条规则优先级递减。</p><h2 id="new-操作符做的事情">new 操作符做的事情</h2><ol><li>新生成一个新对象</li><li>链接到原型</li><li>绑定 <code>this</code></li><li>返回新对象</li></ol><h2 id="node-读写大文件">node 读写大文件</h2><p>流是一种抽象的数据结构。想象水流，当在水管中流动时，就可以从某个地方（例如自来水厂）源源不断地到达另一个地方（比如你家的洗手池）。有些流用来读取数据，比如从文件读取数据时，可以打开一个文件流，然后从文件流中不断地读取数据。在 Node.js 中，流也是一个对象，我们只需要响应流的事件就可以了：data 事件表示流的数据已经可以读取了，end 事件表示这个流已经到末尾了，没有数据可以读取了，error 事件表示出错了。</p><p>流读取数据：</p><pre><code class="language-js"><span class="hljs-keyword">var</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;fs&quot;</span>);

<span class="hljs-comment">// 打开一个流:</span>
<span class="hljs-keyword">var</span> rs = fs.<span class="hljs-title function_">createReadStream</span>(<span class="hljs-string">&quot;sample.txt&quot;</span>, <span class="hljs-string">&quot;utf-8&quot;</span>);

<span class="hljs-comment">// data事件可能会有多次，每次传递的chunk是流的一部分数据。</span>
rs.<span class="hljs-title function_">on</span>(<span class="hljs-string">&quot;data&quot;</span>, <span class="hljs-keyword">function</span> (<span class="hljs-params">chunk</span>) {
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;DATA:&quot;</span>);
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(chunk);
});

rs.<span class="hljs-title function_">on</span>(<span class="hljs-string">&quot;end&quot;</span>, <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) {
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;END&quot;</span>);
});

rs.<span class="hljs-title function_">on</span>(<span class="hljs-string">&quot;error&quot;</span>, <span class="hljs-keyword">function</span> (<span class="hljs-params">err</span>) {
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;ERROR: &quot;</span> + err);
});
</code></pre><h2 id="箭头函数">箭头函数</h2><ol><li>箭头函数没有自己的 <code>this</code> 对象</li><li>不可以当作构造函数，也就是说，不可以对箭头函数使用 <code>new</code> 命令，否则会抛出一个错误。</li><li>不可以使用 <code>arguments</code> 对象，该对象在函数体内不存在。</li><li>不可以使用 <code>yield</code> 命令，因此箭头函数不能用作 <code>Generator</code> 函数</li></ol><p>对于普通函数来说，内部的 <code>this</code> 指向函数运行时所在的对象，但是这一点对箭头函数不成立。它没有自己的 <code>this</code> 对象，内部的 <code>this</code> 就是<strong>定义时</strong>上层作用域中的 <code>this</code>。也就是说，箭头函数内部的 <code>this</code> 指向是固定的，相比之下，普通函数的 <code>this</code> 指向是可变的。</p><pre><code class="language-js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params"></span>) {
  <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;id:&quot;</span>, <span class="hljs-variable language_">this</span>.<span class="hljs-property">id</span>); <span class="hljs-comment">// 这个 this 是函数 foo 里的 this</span>
  }, <span class="hljs-number">100</span>);
}

<span class="hljs-keyword">var</span> id = <span class="hljs-number">21</span>;

foo.<span class="hljs-title function_">call</span>({ <span class="hljs-attr">id</span>: <span class="hljs-number">42</span> }); <span class="hljs-comment">// id: 42</span>

<span class="hljs-keyword">function</span> <span class="hljs-title function_">bar</span>(<span class="hljs-params"></span>) {
  <span class="hljs-built_in">setTimeout</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;id:&quot;</span>, <span class="hljs-variable language_">this</span>.<span class="hljs-property">id</span>); <span class="hljs-comment">// 这个 this 在运行的时候会指向 window</span>
  }, <span class="hljs-number">100</span>);
}

<span class="hljs-keyword">var</span> id = <span class="hljs-number">24</span>;

bar.<span class="hljs-title function_">call</span>({ <span class="hljs-attr">id</span>: <span class="hljs-number">42</span> });
</code></pre><p>Babel 转箭头函数产生的 ES5 代码：</p><pre><code class="language-js"><span class="hljs-comment">// ES6</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params"></span>) {
  <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;id:&quot;</span>, <span class="hljs-variable language_">this</span>.<span class="hljs-property">id</span>);
  }, <span class="hljs-number">100</span>);
}

<span class="hljs-comment">// ES5</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params"></span>) {
  <span class="hljs-keyword">var</span> _this = <span class="hljs-variable language_">this</span>;

  <span class="hljs-built_in">setTimeout</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;id:&quot;</span>, _this.<span class="hljs-property">id</span>);
  }, <span class="hljs-number">100</span>);
}
</code></pre><p>需要注意，函数中才有 <code>this</code>，<code>Object</code> 中没有 <code>this</code>，<code>this</code> 的指向是 <code>Object</code>：</p><pre><code class="language-js"><span class="hljs-comment">// ES6</span>
<span class="hljs-keyword">const</span> cat = {
  <span class="hljs-attr">lives</span>: <span class="hljs-number">9</span>,
  <span class="hljs-attr">jumps</span>: <span class="hljs-function">() =&gt;</span> {
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">lives</span>--; <span class="hljs-comment">// 指向了全局</span>
  },
};

<span class="hljs-comment">// ES5</span>
<span class="hljs-keyword">var</span> _this = <span class="hljs-variable language_">this</span>;
<span class="hljs-keyword">var</span> cat = {
  <span class="hljs-attr">lives</span>: <span class="hljs-number">9</span>,
  <span class="hljs-attr">jumps</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) {
    _this.<span class="hljs-property">lives</span>--;
  },
};
</code></pre><p>ES6 的 <code>Class</code> 本质也是函数，所以里边的箭头函数指向了该 <code>Class</code> 实例：</p><pre><code class="language-js"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Point</span> {
  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">x, y</span>) {
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">x</span> = x;
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">y</span> = y;
  }

  getX = <span class="hljs-function">() =&gt;</span> {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;arrow&quot;</span>, <span class="hljs-variable language_">this</span>);
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">x</span>);
  };

  <span class="hljs-title function_">getY</span>(<span class="hljs-params"></span>) {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;function&quot;</span>, <span class="hljs-variable language_">this</span>);
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">y</span>);
  }
}

<span class="hljs-keyword">const</span> point = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Point</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>);

<span class="hljs-comment">// 作为实例属性调用，都指向实例</span>
point.<span class="hljs-title function_">getX</span>();
<span class="hljs-comment">// arrow Point {x: 1, y: 2, getX: ƒ}</span>
<span class="hljs-comment">// 1</span>
point.<span class="hljs-title function_">getY</span>();
<span class="hljs-comment">// function Point {x: 1, y: 2, getX: ƒ}</span>
<span class="hljs-comment">// 2</span>

<span class="hljs-comment">// 作为单独的函数调用，箭头函数的指向不变，依然是实例，普通函数指向 undefined</span>
<span class="hljs-keyword">const</span> { getX, getY } = point;
<span class="hljs-title function_">getX</span>();
<span class="hljs-comment">// arrow Point {x: 1, y: 2, getX: ƒ}</span>
<span class="hljs-comment">// 1</span>
<span class="hljs-title function_">getY</span>();
<span class="hljs-comment">// function undefined</span>
<span class="hljs-comment">// Uncaught TypeError: Cannot read properties of undefined (reading &#x27;y&#x27;)</span>
</code></pre><p>箭头函数属性和普通函数属性在类中的继承细节：</p><pre><code class="language-js"><span class="hljs-keyword">class</span> <span class="hljs-title class_">B</span> {
  print = <span class="hljs-function">() =&gt;</span> {
    <span class="hljs-comment">// 函数1</span>
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;print b&quot;</span>);
  };
}

<span class="hljs-keyword">class</span> <span class="hljs-title class_">D</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">B</span> {
  <span class="hljs-title function_">print</span>(<span class="hljs-params"></span>) {
    <span class="hljs-comment">// 函数2</span>
    <span class="hljs-variable language_">super</span>.<span class="hljs-title function_">print</span>();
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;print d&quot;</span>);
  }
}

<span class="hljs-keyword">const</span> d = <span class="hljs-keyword">new</span> <span class="hljs-title function_">D</span>();
<span class="hljs-comment">// 实际上只会运行一次函数1，函数2不运行</span>
d.<span class="hljs-title function_">print</span>(); <span class="hljs-comment">// print b</span>
</code></pre><p>常规的写法中，类的非静态属性都是定义在类的原型对象上，而不是类的实例上的。但箭头函数不一样，通过箭头函数定义的方法时绑定在 <code>this</code> 上，而 <code>this</code> 是指向当前创建的类实例对象，而不是类的原型对象。</p><p>可以查看类转换后的代码：</p><pre><code class="language-js"><span class="hljs-keyword">var</span> B = <span class="hljs-keyword">function</span> <span class="hljs-title function_">B</span>(<span class="hljs-params"></span>) {
  <span class="hljs-title function_">_classCallCheck</span>(<span class="hljs-variable language_">this</span>, B);

  <span class="hljs-comment">// 箭头函数绑定在了 this 上，不是原型上</span>
  <span class="hljs-variable language_">this</span>.<span class="hljs-property">print</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;print b&quot;</span>);
  };
};

<span class="hljs-keyword">function</span> <span class="hljs-title function_">D</span>(<span class="hljs-params"></span>) {
  <span class="hljs-comment">// 继承自 B</span>
  <span class="hljs-variable language_">this</span>.<span class="hljs-property">print</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;print b&quot;</span>);
  };
}

<span class="hljs-comment">// 通过原型实现继承</span>
D.<span class="hljs-property">__proto__</span> = B;
D.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">__proto__</span> === B.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>;

D.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">print</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) {
  <span class="hljs-comment">// 类 D 自身定义的 print 方法</span>
};

<span class="hljs-keyword">const</span> d = <span class="hljs-keyword">new</span> <span class="hljs-title function_">D</span>();
<span class="hljs-comment">// print 会先取实例中的属性，取到就不会在原型中找了。</span>
d.<span class="hljs-title function_">print</span>(); <span class="hljs-comment">// print b</span>
</code></pre><p>延伸：ES6 的继承和 ES5 的继承有什么区别？</p><blockquote><p>ES5 的继承，实质是先创造子类的实例对象 <code>this</code>，然后再将父类的方法添加到 <code>this</code> 上面（<code>Parent.apply(this)</code>）。ES6 的继承机制完全不同，实质是先将父类实例对象的属性和方法，加到 <code>this</code> 上面（所以必须先调用 <code>super</code> 方法），然后再用子类的构造函数修改 <code>this</code>。</p></blockquote><h2 id="promise">Promise</h2><pre><code class="language-js"><span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> {
  <span class="hljs-title function_">resolve</span>(<span class="hljs-number">1</span>);
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">2</span>);
}).<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">r</span>) =&gt;</span> {
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(r);
});

<span class="hljs-comment">// 2</span>
<span class="hljs-comment">// 1</span>
</code></pre><p>上面代码中，调用 <code>resolve(1)</code> 以后，后面的 <code>console.log(2)</code> 还是会执行，并且会首先打印出来。这是因为立即 <code>resolved</code> 的 <code>Promise</code> 是在本轮事件循环的末尾执行，总是晚于本轮循环的同步任务。</p></section></div><div id="footer_wrap" class="outer"><footer class="inner"><p class="update-time"></p><p class="copyright">zhangxk-notes maintained by <a href="https://github.com/zhangxuekang">zhangxuekang</a></p></footer></div></body></html>
## 性能优化：

1. 减少请求
2. 使用服务端渲染
3. 使用 cdn
4. css 头部，js 底部
5. 压缩文件
6. 图片优化（不用图片，延迟加载）
7. 减少重绘、回流
8. 使用事件委托

### 首屏加载优化

1. cdn 分发（减少传输距离）
2. 后端在业务层的缓存，接口缓存
3. 静态文件缓存方案，文件 hash+强缓存的一个方案。比如 hash+ cache control: max-age=1 年。
4. 前端的资源动态加载
   1. 路由动态加载，最常用的做法，以页面为单位，进行动态加载
   2. 组件动态加载(offScreen Component)，对于不在当前视窗的组件，先不加载
   3. 图片懒加载(offScreen Image)
   4. 代码分割，分割业务代码和库代码,分割方式: 配置 + 同步引入 与 动态引入(无需做任何配置)，SplitChunksPlugin 插件
5. 页面使用骨架屏，没有骨架屏的话，一个 loading 图也是可以的。
   1. html-webpack-plugin 插件，在其中配置 html ，可以在文件中插入 loading 图。
6. 使用 ssr 渲染
7. 使用 http 压缩
   1. http 压缩通常是通过在 reponse header 指定 Content-Encoding 首部，告诉客户端 response 的压缩格式，这样客户端才能正确解压。
   2. 压缩值：Content-Encoding: gzip、Content-Encoding: br
   3. webpack 配置，安装 compression-webpack-plugin 插件进行压缩。
8. 利用好 script 标签的 async 和 defer 这两个属性。

## 攻击

CSRF / XSRF（跨站请求伪造）盗用了身份，浏览危险网站
token，添加验证码、密码等，涉及到数据修改操作严格使用 post 请求而不是 get 请求

XSS/CSS（跨站脚本攻击）植入恶意脚本
对用户输入内容和服务端返回内容进行过滤和转译

ClickJacking（点击劫持）利用透明 iframe 覆盖原网页诱导用户进行某些操作达成目的。

## 缓存

强制缓存优先于协商缓存进行，若强制缓存(Expires 和 Cache-Control)生效则直接使用缓存，若不生效则进行协商缓存

(Last-Modified / If-Modified-Since 和 Etag / If-None-Match)，协商缓存由服务器决定是否使用缓存，若协商缓存效，那么代表该请求的缓存失效，重新获取请求结果，再存入浏览器缓存中；生效则返回 304，继续使用缓存

Expires 是到时间点过期，Cache-Control 可以设置一段时间后过期（精确到秒）。

- Expires：Expires 受限于本地时间，如果修改了本地时间，可能会造成缓存失效。
- Last-Modified：如果本地打开缓存文件，即使没有对文件进行修改，但还是会造成 Last-Modified 被修改，服务端不能命中缓存导致发送相同的资源。因为 Last-Modified 只能以秒计时，如果在不可感知的时间内修改完成文件，那么服务端会认为资源还是命中了，不会返回正确的资源

### Memory Cache

Memory Cache 也就是内存中的缓存，主要包含的是当前中页面中已经抓取到的资源,例如页面上已经下载的样式、脚本、图片等。读取内存中的数据肯定比磁盘快,内存缓存虽然读取高效，可是缓存持续性很短，会随着进程的释放而释放。 一旦我们关闭 Tab 页面，内存中的缓存也就被释放了。内存缓存在缓存资源时并不关心返回资源的 HTTP 缓存头 Cache-Control 是什么值，同时资源的匹配也并非仅仅是对 URL 做匹配，还可能会对 Content-Type，CORS 等其他特征做校验。

### Disk Cache

Disk Cache 也就是存储在硬盘中的缓存，读取速度慢点，但是什么都能存储到磁盘中，比之 Memory Cache 胜在容量和存储时效性上。它会根据 HTTP Herder 中的字段判断哪些资源需要缓存，哪些资源可以不请求直接使用，哪些资源已经过期需要重新请求。并且即使在跨站点的情况下，相同地址的资源一旦被硬盘缓存下来，就不会再次去请求数据。绝大部分的缓存都来自 Disk Cache。

对于大文件来说，大概率是不存储在内存中的，反之优先；
当前系统内存使用率高的话，文件优先存储进硬盘

### 用户行为对浏览器缓存的影响

- 打开网页，地址栏输入地址： 查找 disk cache 中是否有匹配。如有则使用；如没有则发送网络请求。
- 普通刷新 (F5)：因为 TAB 并没有关闭，因此 memory cache 是可用的，会被优先使用(如果匹配的话)。其次才是 disk cache。
- 强制刷新 (Ctrl + F5)：浏览器不使用缓存，因此发送的请求头部均带有 Cache-control: no-cache(为了兼容，还带了 Pragma: no-cache),服务器直接返回 200 和最新内容。

## 浏览器的渲染过程主要包括以下几步：

1. 解析 HTML 生成 **DOM** 树。
2. 解析 CSS 生成 CSSOM **规则树**。
3. 将 DOM 树与 CSSOM 规则树合并在一起生成**渲染树**。
4. 遍历渲染树开始**布局**，计算每个节点的位置大小信息。
5. 将渲染树每个节点**绘制**到屏幕。

## 从输入 URL 到页面展示到底发生了什么？

1. 输入地址
2. 浏览器查找域名的 IP 地址
   1. 浏览器会首先查看本地硬盘的 hosts 文件，看看其中有没有和这个域名对应的规则，如果有的话就直接使用 hosts 文件里面的 ip 地址。
   2. 如果在本地的 hosts 文件没有能够找到对应的 ip 地址，浏览器会发出一个 DNS 请求到本地 DNS 服务器
      1. 本地 DNS 服务器会首先查询它的缓存记录，如果缓存中有此条记录，就可以直接返回结果，此过程是递归的方式进行查询。如果没有，本地 DNS 服务器还要向 DNS 根服务器进行查询。
      2. ...
3. 浏览器向 web 服务器发送一个 HTTP 请求
   1. 建立 TCP/IP 的连接（三次握手），发起一个 http 请求
   2. 三次握手的目的：防止已失效的连接请求报文段突然又传送到了服务端，因而产生错误
4. 服务器的永久重定向响应
   1. 301 表示旧地址 A 的资源已经被永久地移除了（这个资源不可访问了），搜索引擎在抓取新内容的同时也将旧的网址交换为重定向之后的网址
   2. 302 表示旧地址 A 的资源还在（仍然可以访问），这个重定向只是临时地从旧地址 A 跳转到地址 B，搜索引擎会抓取新的内容而保存旧的网址
5. 浏览器跟踪重定向地址（发送另一个 http）
6. 服务器处理请求
7. 服务器返回一个 HTTP 响应
   1. 1xx：信息性状态码，表示服务器已接收了客户端请求，客户端可继续发送请求。
   2. 2xx：成功状态码，表示服务器已成功接收到请求并进行处理。
   3. 3xx：重定向状态码，表示服务器要求客户端重定向。
   4. 4xx：客户端错误状态码，表示客户端的请求有非法内容。
   5. 5xx：服务器错误状态码，表示服务器未能正常处理客户端的请求而出现意外错误。
8. 浏览器显示 HTML
   1. 浏览器在解析 html 文件时，会**自上而下**加载，并在加载过程中进行解析渲染。在解析过程中，如果遇到请求外部资源时，如图片、外链的 CSS、iconfont 等，请求过程是**异步**的，并不会影响 html 文档进行加载。
   2. 浏览器首先会解析 HTML 文件构建 DOM 树，然后解析 CSS 文件构建渲染树，等到渲染树构建完成后，浏览器开始布局渲染树并将其绘制到屏幕上。
   3. 当文档加载过程中遇到 js 文件，html 文档会挂起渲染（加载解析渲染同步）的线程，不仅要等待文档中 js 文件加载完毕，还要等待解析执行完毕，才可以恢复 html 文档的渲染线程。
9. 浏览器发送请求获取嵌入在 HTML 中的资源（如图片、音频、视频、CSS、JS 等等）
   1. 其实这个步骤可以并列在步骤 8 中，在浏览器显示 HTML 时，它会注意到需要获取其他地址内容的标签。
   2. 这些地址都要经历一个和 HTML 读取类似的过程。所以浏览器会在 DNS 中查找这些域名，发送请求，重定向等等…
   3. 静态文件会允许浏览器对其进行缓存

## OSI 模型

开放式系统互联模型（英语：Open System Interconnection Model，缩写：OSI；简称为 OSI 模型）是一种概念模型，由国际标准化组织提出，一个试图使各种计算机在世界范围内互连为网络的标准框架。

| 层数              | 说明                                                                         | 例子                                                   |
| ----------------- | ---------------------------------------------------------------------------- | ------------------------------------------------------ |
| 第七层 应用层     | 应用层提供为应用软件而设计的接口，以设置与另一应用软件之间的通信。           | HTTP、HTTPS、FTP、Telnet、SSH、SMTP、POP3              |
| 第六层 表示层     | 表示层把数据转换为能与接收者的系统格式兼容并适合传输的格式。                 | -                                                      |
| 第五层 会话层     | 会话层负责在数据传输中设置和维护计算机网络中两台计算机之间的通信连接         | -                                                      |
| 第四层 传输层     | 传输层把传输表头加至数据以形成数据包。传输表头包含了所使用的协议等发送信息。 | TCP                                                    |
| 第三层 网络层     | 网络层决定数据的路径选择和转寄，将网络表头加至数据包，以形成分组。           | IP                                                     |
| 第二层 数据链路层 | 数据链路层负责网络寻址、错误侦测和改错                                       | -                                                      |
| 第一层 物理层     | 物理层在局部局域网上发送数据帧，它负责管理电脑通信设备和网络媒体之间的互通。 | 针脚、电压、线缆规范、集线器、中继器、网卡、主机接口卡 |

## 跨域

因为浏览器出于安全考虑，有同源策略。也就是说，如果协议、域名或者端口有一个不同就是跨域，Ajax 请求会失败。 其实主要是用来防止 CSRF 攻击的。简单点说，CSRF 攻击是利用用户的登录态发起恶意请求。

**跨域并不是请求发不出去，请求能发出去，服务端能收到请求并正常返回结果，只是结果被浏览器拦截了。**因为归根结底，跨域是为了阻止用户读取到另一个域名下的内容，Ajax 可以获取响应，浏览器认为这不安全，所以拦截了响应。

### jsonp

\<script\> 标签没有跨域，通过 \<script\>标签指向一个需要访问的地址并提供一个回调函数来接收数据。

JSONP 使用简单且兼容性不错，但是只限于 get 请求。

```js
<script src="http://domain/api?param1=a&param2=b&callback=jsonp"></script>
<script>
    function jsonp(data) {
    	console.log(data)
	}
</script>
```

### CORS

当你使用 `XMLHttpRequest` 发送请求时，浏览器发现该请求不符合同源策略，会给该请求加一个请求头：`Origin`，后台进行一系列处理，如果确定接受请求则在返回结果中加入一个响应头：`Access-Control-Allow-Origin`;  浏览器判断该相应头中是否包含 `Origin` 的值，如果有则浏览器会处理响应，我们就可以拿到响应数据。

服务端设置 `Access-Control-Allow-Origin` 就可以开启 `CORS`。

通过这种方式解决跨域问题的话，会在发送请求时出现两种情况，分别为简单请求和复杂请求。

当满足以下条件时，会触发简单请求

1. 使用下列方法之一：`GET、HEAD、POST`
2. Content-Type 的值仅限于下列三者之一：`text/plain、multipart/form-data、application/x-www-form-urlencoded`

对于复杂请求来说，首先会发起一个预检请求，该请求是 option 方法的，通过该请求来知道服务端是否允许跨域请求。

### document.domain

该方式只能用于主域名相同的情况下，比如 `a.test.com` 和 `b.test.com` 适用于该方式。只需要给页面添加 `document.domain = 'test.com'` 表示主域名都相同就可以实现跨域

### postMessage

这种方式通常用于获取嵌入页面中的第三方页面数据。一个页面发送消息，另一个页面判断来源并接收消息

```js
// 发送消息端
window.parent.postMessage("hello", "http://test.com");

// 接收消息端
window.addEventListener("message", (event) => {
  var origin = event.origin || event.originalEvent.origin;
  if (origin === "http://test.com") {
    console.log("验证通过");
  }
});
```

### 为什么操作 DOM 慢

因为 **`DOM` 是属于渲染引擎中的东西**，而 `JS` 又是 `JS` 引擎中的东西。当我们通过 `JS` 操作 `DOM` 的时候，其实这个操作涉及到了**两个线程之间的通信**，那么势必会带来一些性能上的损耗。操作 `DOM` 次数一多，也就等同于一直在进行线程之间的通信，并且操作 `DOM` 可能还会带来**重绘回流**的情况，所以也就导致了性能上的问题。

### 插入几万个 DOM，如何实现页面不卡顿？

解决问题的重点应该是如何分批次部分渲染 `DOM`:

1. 通过 `requestAnimationFrame` 的方式去循环的插入 `DOM`。
2. 虚拟滚动（virtualized scroller），只渲染可视区域内的内容，非可见区域的那就完全不渲染了，当用户在滚动的时候就实时去替换渲染的内容。

### defer 和 async 的区别

![defer VS async](../../assets/defer_async.jpeg)

1. defer 和 async 在网络读取（下载）这块儿是一样的，都是异步的（相较于 HTML 解析）
2. 它俩的差别在于脚本下载完之后何时执行，显然 defer 是最接近我们对于应用脚本加载和执行的要求的，所有元素解析完成之后执行
3. 关于 defer，此图未尽之处在于它是按照加载顺序执行脚本的，这一点要善加利用
4. async 则是一个乱序执行的主，反正对它来说脚本的加载和执行是紧紧挨着的，所以不管你声明的顺序如何，**只要它加载完了就会立刻执行**
5. 仔细想想，async 对于应用脚本的用处不大，因为它完全不考虑依赖（哪怕是最低级的顺序执行），不过它对于那些可以不依赖任何脚本或不被任何脚本依赖的脚本来说却是非常合适的

## webpack

本质上,webpack 是一个现代 JavaScript 应用程序的静态模块打包器(module bundler)。当 webpack 处理应用程序时,它会递归地构建一个依赖关系图(dependency graph),其中包含应用程序需要的每个模块,然后将所有这些模块打包成一个或多个 bundle。

webpack 就像一条生产线,要经过一系列处理流程后才能将源文件转换成输出结果。插件就像是一个插入到生产线中的一个功能,在特定的时机对生产线上的资源做处理。webpack 在运行过程中会广播事件,插件只需要监听它所关心的事件,就能加入到这条生产线中,去改变生产线的运作。

### loader

loader 让 webpack 能够去处理那些非 JavaScript 文件（webpack 自身只理解 JavaScript）。loader 可以将所有类型的文件转换为 webpack 能够处理的有效模块,然后你就可以利用 webpack 的打包能力,对它们进行处理。

### Plugin

loader 被用于转换某些类型的模块,而插件则可以用于执行范围更广的任务。插件的范围包括,从打包优化和压缩,一直到重新定义环境中的变量。插件接口功能极其强大,可以用来处理各种各样的任务。

#### 常用插件

- DefinePlugin：编译时创建全局对象，是一个 webpack 内置的插件，不需要安装
- HtmlWebpackPlugin：在打包结束后，动态生成 html 文件，并把打包生成的 js 模块引到该 html 中。
- HotModuleReplacementPlugin：模块热更新插件。依赖于 webpack-dev-server，后者是在打包文件改变时更新打包文件或者 reload 刷新整个页面，HRM 是只更新修改的部分。
- clean-webpack-plugin：用于在打包前清理上一次项目生成的 bundle 文件，它会根据 output.path 自动清理文件夹
- terser-webpack-plugin：用来对 js 文件进行压缩，从而减小 js 文件的大小，加速 load 速度

### 构建流程

Webpack 的运行流程是一个串行的过程,从启动到结束会依次执行以下流程 :

1. **初始化参数**：从配置文件和 Shell 语句中读取与合并参数,得出最终的参数。
2. **开始编译**：用上一步得到的参数初始化 Compiler 对象,加载所有配置的插件,执行对象的 run 方法开始执行编译。
3. **确定入口**：根据配置中的 entry 找出所有的入口文件。
4. **编译模块**：从入口文件出发,调用所有配置的 Loader 对模块进行翻译,再找出该模块依赖的模块,再递归本步骤直到所有入口依赖的文件都经过了本步骤的处理。
5. **完成模块编译**：在经过第 4 步使用 Loader 翻译完所有模块后,得到了每个模块被翻译后的最终内容以及它们之间的*依赖关系*。
6. **输出资源**：根据入口和模块之间的依赖关系,组装成一个个包含多个模块的 Chunk,再把每个 Chunk 转换成一个单独的文件加入到输出列表,这步是可以修改输出内容的最后机会。
7. **输出完成**：在确定好输出内容后,根据配置确定输出的路径和文件名,把文件内容写入到文件系统。

在以上过程中,Webpack 会在特定的时间点**广播出特定的事件**,插件在监听到感兴趣的事件后会执行特定的逻辑,并且插件可以调用 Webpack 提供的 API 改变 Webpack 的运行结果。

## CDN

CDN 是将源站内容分发至全国所有的节点，从而缩短用户查看对象的延迟，提高用户访问网站的响应速度与网站的可用性的技术。它能够有效解决网络带宽小、用户访问量大、网点分布不均等问题。

其目的是使用户可就近取得所需内容，解决 Internet 网络拥挤的状况，提高用户访问网站的响应速度。

1. 用户向浏览器输入域名，浏览器第一次发现本地没有 dns 缓存，则向网站的 DNS 服务器请求；
2. 网站的 DNS 域名解析器设置了 CNAME,请求指向了 CDN 网络中的智能 DNS 负载均衡系统；
3. 智能 DNS 负载均衡系统解析域名，把对用户响应速度最快的 IP 节点返回给用户；
4. 用户向该 IP 节点（CDN 服务器）发出请求；
5. 由于是第一次访问，CDN 服务器会向原 web 站点请求，并缓存内容；
6. 请求结果发给用户。

## tree shaking 的原理是什么?

ES6 Module 引入进行静态分析，故而编译的时候正确判断到底加载了那些模块，静态分析程序流，判断那些模块和变量未被使用或者引用，进而删除对应代码。

1. CommonJS 模块输出的是一个值的拷贝，ES6 模块输出的是值的引用。
2. CommonJS 模块是运行时加载，ES6 模块是编译时输出接口。
3. CommonJs 是单个值导出，ES6 Module 可以导出多个
4. CommonJs 是动态语法可以写在判断里，ES6 Module 静态语法只能写在顶层
5. CommonJs 的 this 是当前模块，ES6 Module 的 this 是 undefined

禁止 Babel 将 ES6 编译到 CommonJS。

webpack4 的 mode 集成了多个优化项，在 produciton 模式下默认开启了 Tree Shaking。

sideEffects 可以配置文件导出默认都是无副作用的，在项目中启用后可以减少打包体积。

按需导入。

## 路由 hash 模式和 history 模式的区别

hash 模式 url 带#号，history 模式不带#号。

hash 模式：hash 虽然出现在 URL 中，但不会被包括在 HTTP 请求中，对后端完全没有影响，因此改变 hash 不会重新加载页面。监听 window.onhashchange 事件。带#号不美观。对外分享链接的时候，#后边的内容可能会丢失。

history 模式：利用了 HTML5 History Interface 中新增的 pushState() 和 replaceState() 方法。这两个方法应用于浏览器的历史记录栈，在当前已有的 back()、forward()、go() 方法的基础之上，这两个方法提供了对历史记录进行修改的功能。当这两个方法执行修改时，只能改变当前地址栏的 URL，但浏览器不会向后端发送请求，也不会触发 popstate 事件的执行。但是页面刷新会重新请求，可能会导致页面 404，需要后端配合支持（nginx 路由转发重定向等）。

## 兼容性问题

- 对一行文字设置了 line-height 等于 height 垂直居中，但是在 Android 的浏览器上会偏上一点。
  - 将字体、高度放大一倍后缩小，transform: scale(0.5)
  - 使用 vertical-align 属性居中
  - （百度）安卓手机 line-height 设置比 height 大 1px
- click 事件 300ms 延迟。为了监听是否是双击缩放事件。
  - 禁用缩放
  - 用 touchstart 代替
- iphone x 上判断滚动到底， scrollTop + clientHeight !== scrollHeight，差一像素。

## 轮询、长轮询(comet)、长连接(SSE)、WebSocket

### 轮询

浏览器每隔一段时间向浏览器发送 http 请求，服务器端在收到请求后，不论是否有数据更新，都直接进行响应。需要不断的建立 http 连接，严重浪费了服务器端和客户端的资源。

### 长轮询(comet)

长轮询本质上也是轮询，只不过对普通的轮询做了优化处理，服务端在没有数据的时候并不是马上返回数据，会 hold 住请求，等待服务端有数据，或者一直没有数据超时处理，然后一直循环下去。长轮询和短轮询比起来，明显减少了很多不必要的 http 请求次数，相比之下节约了资源。长轮询的缺点在于，连接挂起也会导致资源的浪费。

### 长连接(SSE)

服务器向客户端声明，接下来要发送的是流信息（streaming）。也就是说，发送的不是一次性的数据包，而是一个数据流，会连续不断地发送过来。这时，客户端不会关闭连接，会一直等着服务器发过来的新的数据流，视频播放就是这样的例子。SSE 是单向通道，只能服务器向浏览器发送，因为流信息本质上就是下载。

Http/1.1 想出了持久化连接。只要任意一端没有明确的提出 断开连接，则保持 TCP 连接状态。通过首部字段 Connection：Keep-Alive 实现。Http/1.1 默认为长连接。

### WebSocket

服务器可以主动向客户端推送信息，客户端也可以主动向服务器发送信息，是真正的双向平等对话。没有同源限制，客户端可以与任意服务器通信。

#### websocket 心跳及重连机制

websocket 是前后端交互的长连接，前后端也都可能因为一些情况导致连接失效并且相互之间没有反馈提醒。因此为了保证连接的可持续性和稳定性，websocket 心跳重连就应运而生。心跳机制是每隔一段时间会向服务器发送一个数据包，告诉服务器自己还活着，同时客户端会确认服务器端是否还活着，如果还活着的话，就会回传一个数据包给客户端来确定服务器端也还活着，否则的话，有可能是网络断开连接了，需要重连。

## 大文件分片上传

Blob 对象表示一个不可变、原始数据的类文件对象。它的数据可以按文本或二进制的格式进行读取，同时提供了对数据截取的方法 slice，而 file 继承了 Blob 的功能，所以可以使用此方法将读取的文件进行分片切割，用以拼凑准备上传的数据。

1. 把大文件进行分段 比如 2M，发送到服务器携带一个标志，暂时使用当前的时间戳，用于标识一个完整文件
2. 服务端保存各段文件；
3. 浏览器端所有分片上传完成，发送给服务端一个合并文件的请求
4. 服务端根据文件标识、类型、各分片顺序进行文件合并

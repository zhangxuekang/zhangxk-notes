## 移动端 click 事件 300ms 的延迟响应

1. 禁用缩放

```html
<meta name="viewport" content="user-scalable=no" />
<meta name="viewport" content="initial-scale=1,maximum-scale=1" />
```

2. touchstart 代替

## 性能优化：

1. 减少请求
2. 使用服务端渲染
3. 使用 cdn
4. css 头部，js 底部
5. 压缩文件
6. 图片优化（不用图片，延迟加载）
7. 减少重绘、回流
8. 使用事件委托

## GET VS POST

- GET 在浏览器回退时是无害的，而 POST 会再次提交请求。
- GET 产生的 URL 地址可以被 Bookmark，而 POST 不可以。
- GET 请求会被浏览器主动 cache，而 POST 不会，除非手动设置。
- GET 请求只能进行 url 编码，而 POST 支持多种编码方式。
- GET 请求参数会被完整保留在浏览器历史记录里，而 POST 中的参数不会被保留。
- GET 请求在 URL 中传送的参数是有长度限制的，而 POST 么有。
- 对参数的数据类型，GET 只接受 ASCII 字符，而 POST 没有限制。
- GET 比 POST 更不安全，因为参数直接暴露在 URL 上，所以不能用来传递敏感信息。
- GET 参数通过 URL 传递，POST 放在 Request body 中。

## 攻击

CSRF / XSRF（跨站请求伪造）盗用了身份，浏览危险网站
token，添加验证码、密码等，涉及到数据修改操作严格使用 post 请求而不是 get 请求

XSS/CSS（跨站脚本攻击）植入恶意脚本
对用户输入内容和服务端返回内容进行过滤和转译

ClickJacking（点击劫持）利用透明 iframe 覆盖原网页诱导用户进行某些操作达成目的。

## 缓存

强制缓存优先于协商缓存进行，若强制缓存(Expires 和 Cache-Control)生效则直接使用缓存，若不生效则进行协商缓存

(Last-Modified / If-Modified-Since 和 Etag / If-None-Match)，协商缓存由服务器决定是否使用缓存，若协商缓存效，那么代表该请求的缓存失效，重新获取请求结果，再存入浏览器缓存中；生效则返回 304，继续使用缓存

Expires 是到时间点过期，Cache-Control 可以设置一段时间后过期（精确到秒）。

- Expires：Expires 受限于本地时间，如果修改了本地时间，可能会造成缓存失效。
- Last-Modified：如果本地打开缓存文件，即使没有对文件进行修改，但还是会造成 Last-Modified 被修改，服务端不能命中缓存导致发送相同的资源。因为 Last-Modified 只能以秒计时，如果在不可感知的时间内修改完成文件，那么服务端会认为资源还是命中了，不会返回正确的资源

## 浏览器的渲染过程主要包括以下几步：

1. 解析 HTML 生成 **DOM** 树。
2. 解析 CSS 生成 CSSOM **规则树**。
3. 将 DOM 树与 CSSOM 规则树合并在一起生成**渲染树**。
4. 遍历渲染树开始**布局**，计算每个节点的位置大小信息。
5. 将渲染树每个节点**绘制**到屏幕。

## 从输入 URL 到页面展示到底发生了什么？

1. 输入地址
2. 浏览器查找域名的 IP 地址
   1. 浏览器会首先查看本地硬盘的 hosts 文件，看看其中有没有和这个域名对应的规则，如果有的话就直接使用 hosts 文件里面的 ip 地址。
   2. 如果在本地的 hosts 文件没有能够找到对应的 ip 地址，浏览器会发出一个 DNS 请求到本地 DNS 服务器
      1. 本地 DNS 服务器会首先查询它的缓存记录，如果缓存中有此条记录，就可以直接返回结果，此过程是递归的方式进行查询。如果没有，本地 DNS 服务器还要向 DNS 根服务器进行查询。
      2. ...
3. 浏览器向 web 服务器发送一个 HTTP 请求
   1. 建立 TCP/IP 的连接（三次握手），发起一个 http 请求
   2. 三次握手的目的：防止已失效的连接请求报文段突然又传送到了服务端，因而产生错误
4. 服务器的永久重定向响应
   1. 301 表示旧地址 A 的资源已经被永久地移除了（这个资源不可访问了），搜索引擎在抓取新内容的同时也将旧的网址交换为重定向之后的网址
   2. 302 表示旧地址 A 的资源还在（仍然可以访问），这个重定向只是临时地从旧地址 A 跳转到地址 B，搜索引擎会抓取新的内容而保存旧的网址
5. 浏览器跟踪重定向地址（发送另一个 http）
6. 服务器处理请求
7. 服务器返回一个 HTTP 响应
   1. 1xx：信息性状态码，表示服务器已接收了客户端请求，客户端可继续发送请求。
   2. 2xx：成功状态码，表示服务器已成功接收到请求并进行处理。
   3. 3xx：重定向状态码，表示服务器要求客户端重定向。
   4. 4xx：客户端错误状态码，表示客户端的请求有非法内容。
   5. 5xx：服务器错误状态码，表示服务器未能正常处理客户端的请求而出现意外错误。
8. 浏览器显示 HTML
   1. 浏览器在解析 html 文件时，会**自上而下**加载，并在加载过程中进行解析渲染。在解析过程中，如果遇到请求外部资源时，如图片、外链的 CSS、iconfont 等，请求过程是**异步**的，并不会影响 html 文档进行加载。
   2. 浏览器首先会解析 HTML 文件构建 DOM 树，然后解析 CSS 文件构建渲染树，等到渲染树构建完成后，浏览器开始布局渲染树并将其绘制到屏幕上。
   3. 当文档加载过程中遇到 js 文件，html 文档会挂起渲染（加载解析渲染同步）的线程，不仅要等待文档中 js 文件加载完毕，还要等待解析执行完毕，才可以恢复 html 文档的渲染线程。
9. 浏览器发送请求获取嵌入在 HTML 中的资源（如图片、音频、视频、CSS、JS 等等）
   1. 其实这个步骤可以并列在步骤 8 中，在浏览器显示 HTML 时，它会注意到需要获取其他地址内容的标签。
   2. 这些地址都要经历一个和 HTML 读取类似的过程。所以浏览器会在 DNS 中查找这些域名，发送请求，重定向等等…
   3. 静态文件会允许浏览器对其进行缓存

## OSI 模型

开放式系统互联模型（英语：Open System Interconnection Model，缩写：OSI；简称为 OSI 模型）是一种概念模型，由国际标准化组织提出，一个试图使各种计算机在世界范围内互连为网络的标准框架。

| 层数              | 说明                                                                         | 例子                                                   |
| ----------------- | ---------------------------------------------------------------------------- | ------------------------------------------------------ |
| 第七层 应用层     | 应用层提供为应用软件而设计的接口，以设置与另一应用软件之间的通信。           | HTTP、HTTPS、FTP、Telnet、SSH、SMTP、POP3              |
| 第六层 表示层     | 表示层把数据转换为能与接收者的系统格式兼容并适合传输的格式。                 | -                                                      |
| 第五层 会话层     | 会话层负责在数据传输中设置和维护计算机网络中两台计算机之间的通信连接         | -                                                      |
| 第四层 传输层     | 传输层把传输表头加至数据以形成数据包。传输表头包含了所使用的协议等发送信息。 | TCP                                                    |
| 第三层 网络层     | 网络层决定数据的路径选择和转寄，将网络表头加至数据包，以形成分组。           | IP                                                     |
| 第二层 数据链路层 | 数据链路层负责网络寻址、错误侦测和改错                                       | -                                                      |
| 第一层 物理层     | 物理层在局部局域网上发送数据帧，它负责管理电脑通信设备和网络媒体之间的互通。 | 针脚、电压、线缆规范、集线器、中继器、网卡、主机接口卡 |

## 写 React / Vue 项目时为什么要在列表组件中写 key

不带有 key，并且使用简单的模板，基于这个前提下，可以更有效的复用节点，diff 速度来看也是不带 key 更加快速的，因为带 key 在增删节点上有耗时。这就是 vue 文档所说的默认模式。但是这个并不是 key 作用，而是没有 key 的情况下可以对节点**就地复用**，提高性能。

这种模式会带来一些隐藏的副作用，比如可能不会产生过渡效果，或者在某些节点有绑定数据（表单）状态，会出现状态错位。

key 是给每一个 vnode 的唯一 id,可以依靠 key,更准确, 更快的拿到 oldVnode 中对应的 vnode 节点。

利用 key 的唯一性生成 map 对象来获取对应节点，比遍历方式更快。

## 跨域

因为浏览器出于安全考虑，有同源策略。也就是说，如果协议、域名或者端口有一个不同就是跨域，Ajax 请求会失败。 其实主要是用来防止 CSRF 攻击的。简单点说，CSRF 攻击是利用用户的登录态发起恶意请求。

### jsonp

\<script\> 标签没有跨域，通过 \<script\>标签指向一个需要访问的地址并提供一个回调函数来接收数据。

JSONP 使用简单且兼容性不错，但是只限于 get 请求。

```js
<script src="http://domain/api?param1=a&param2=b&callback=jsonp"></script>
<script>
    function jsonp(data) {
    	console.log(data)
	}
</script>
```

### CORS

服务端设置 `Access-Control-Allow-Origin` 就可以开启 `CORS`。

通过这种方式解决跨域问题的话，会在发送请求时出现两种情况，分别为简单请求和复杂请求。

当满足以下条件时，会触发简单请求

1. 使用下列方法之一：`GET、HEAD、POST`
2. Content-Type 的值仅限于下列三者之一：`text/plain、multipart/form-data、application/x-www-form-urlencoded`

对于复杂请求来说，首先会发起一个预检请求，该请求是 option 方法的，通过该请求来知道服务端是否允许跨域请求。

### document.domain

该方式只能用于主域名相同的情况下，比如 `a.test.com` 和 `b.test.com` 适用于该方式。只需要给页面添加 `document.domain = 'test.com'` 表示主域名都相同就可以实现跨域

### postMessage

这种方式通常用于获取嵌入页面中的第三方页面数据。一个页面发送消息，另一个页面判断来源并接收消息

```js
// 发送消息端
window.parent.postMessage("hello", "http://test.com");

// 接收消息端
window.addEventListener("message", (event) => {
  var origin = event.origin || event.originalEvent.origin;
  if (origin === "http://test.com") {
    console.log("验证通过");
  }
});
```

### 为什么操作 DOM 慢

因为 **`DOM` 是属于渲染引擎中的东西**，而 `JS` 又是 `JS` 引擎中的东西。当我们通过 `JS` 操作 `DOM` 的时候，其实这个操作涉及到了**两个线程之间的通信**，那么势必会带来一些性能上的损耗。操作 `DOM` 次数一多，也就等同于一直在进行线程之间的通信，并且操作 `DOM` 可能还会带来**重绘回流**的情况，所以也就导致了性能上的问题。

### 插入几万个 DOM，如何实现页面不卡顿？

解决问题的重点应该是如何分批次部分渲染 `DOM`:

1. 通过 `requestAnimationFrame` 的方式去循环的插入 `DOM`。
2. 虚拟滚动（virtualized scroller），只渲染可视区域内的内容，非可见区域的那就完全不渲染了，当用户在滚动的时候就实时去替换渲染的内容。

### defer 和 async 的区别

![defer VS async](../../assets/defer_async.jpeg)

1. defer 和 async 在网络读取（下载）这块儿是一样的，都是异步的（相较于 HTML 解析）
2. 它俩的差别在于脚本下载完之后何时执行，显然 defer 是最接近我们对于应用脚本加载和执行的要求的，所有元素解析完成之后执行
3. 关于 defer，此图未尽之处在于它是按照加载顺序执行脚本的，这一点要善加利用
4. async 则是一个乱序执行的主，反正对它来说脚本的加载和执行是紧紧挨着的，所以不管你声明的顺序如何，**只要它加载完了就会立刻执行**
5. 仔细想想，async 对于应用脚本的用处不大，因为它完全不考虑依赖（哪怕是最低级的顺序执行），不过它对于那些可以不依赖任何脚本或不被任何脚本依赖的脚本来说却是非常合适的

## webpack

本质上,webpack 是一个现代 JavaScript 应用程序的静态模块打包器(module bundler)。当 webpack 处理应用程序时,它会递归地构建一个依赖关系图(dependency graph),其中包含应用程序需要的每个模块,然后将所有这些模块打包成一个或多个 bundle。

webpack 就像一条生产线,要经过一系列处理流程后才能将源文件转换成输出结果。插件就像是一个插入到生产线中的一个功能,在特定的时机对生产线上的资源做处理。webpack 在运行过程中会广播事件,插件只需要监听它所关心的事件,就能加入到这条生产线中,去改变生产线的运作。

### loader

loader 让 webpack 能够去处理那些非 JavaScript 文件（webpack 自身只理解 JavaScript）。loader 可以将所有类型的文件转换为 webpack 能够处理的有效模块,然后你就可以利用 webpack 的打包能力,对它们进行处理。

### Plugin

loader 被用于转换某些类型的模块,而插件则可以用于执行范围更广的任务。插件的范围包括,从打包优化和压缩,一直到重新定义环境中的变量。插件接口功能极其强大,可以用来处理各种各样的任务。

### 构建流程

Webpack 的运行流程是一个串行的过程,从启动到结束会依次执行以下流程 :

1. **初始化参数**：从配置文件和 Shell 语句中读取与合并参数,得出最终的参数。
2. **开始编译**：用上一步得到的参数初始化 Compiler 对象,加载所有配置的插件,执行对象的 run 方法开始执行编译。
3. **确定入口**：根据配置中的 entry 找出所有的入口文件。
4. **编译模块**：从入口文件出发,调用所有配置的 Loader 对模块进行翻译,再找出该模块依赖的模块,再递归本步骤直到所有入口依赖的文件都经过了本步骤的处理。
5. **完成模块编译**：在经过第 4 步使用 Loader 翻译完所有模块后,得到了每个模块被翻译后的最终内容以及它们之间的*依赖关系*。
6. **输出资源**：根据入口和模块之间的依赖关系,组装成一个个包含多个模块的 Chunk,再把每个 Chunk 转换成一个单独的文件加入到输出列表,这步是可以修改输出内容的最后机会。
7. **输出完成**：在确定好输出内容后,根据配置确定输出的路径和文件名,把文件内容写入到文件系统。

在以上过程中,Webpack 会在特定的时间点**广播出特定的事件**,插件在监听到感兴趣的事件后会执行特定的逻辑,并且插件可以调用 Webpack 提供的 API 改变 Webpack 的运行结果。

## Vue VS React

- 使用 **Virtual DOM**
- 都具有基于**组件**的结构
- 提供了**响应式** (Reactive) 和组件化 (Composable) 的视图组件。
- 将注意力集中保持在核心库，而将其他功能如路由和全局状态管理交给相关的库。
- 单向数据流，所有的状态改变(mutation)可追溯，（用函数式来说，保证了组件就是无副作用的纯函数），不至于造成状态总被意外修改而导致难以维护的情况。

### 使用场景

Vue 最适合解决短期的小型的问题，快速迭代的项目。它的体积小巧。React 更偏向于构建稳定大型的应用，非常的科班化。相比之下，Vue 更偏向于简单迅速的解决问题，更灵活，不那么严格遵循条条框框。因此也会给人一种大型项目用 React，小型项目用 Vue 的感觉。

### 模板

在 React 中，所有的组件的渲染功能一般依靠 JSX。Vue 使用 Templates。

> (JSX) 你可以使用完整的编程语言 JavaScript 功能来构建你的视图页面。比如你可以使用临时变量、JS 自带的流程控制、以及直接引用当前 JS 作用域中的值等等。

事实上 Vue 也提供了渲染函数，甚至支持 JSX。然而，vue 推荐的还是模板。

> 模板比起 JSX 读写起来更自然。基于 HTML 的模板使得将已有的应用逐步迁移到 Vue 更为容易。
> 更抽象一点来看，我们可以把组件区分为两类：一类是偏视图表现的 (presentational)，一类则是偏逻辑的 (logical)。我们推荐在前者中使用模板，在后者中使用 JSX 或渲染函数。

React 是在组件 JS 代码中，通过原生 JS 实现模板中的常见语法，比如插值，条件，循环等，都是通过 JS 语法实现的，更加纯粹更加原生。而 Vue 是在和组件 JS 代码分离的单独的模板中，通过指令来实现的，比如条件语句就需要 v-if 来实现对这一点，这样的做法显得有些独特，会把 HTML 弄得很乱。

### 样式

CSS 作用域在 React 中是通过 CSS-in-JS 的方案实现的。这里 React 和 Vue 主要的区别是，Vue 设置样式的默认方法是单文件组件里类似 style 的标签。

### 更新状态

在 React 应用中，当某个组件的状态发生变化时，它会以该组件为根，重新渲染整个组件子树。如要避免不必要的子组件的重渲染，你需要在所有可能的地方使用 PureComponent，或是手动实现 shouldComponentUpdate 方法。在 Vue 应用中，组件的依赖是在渲染过程中自动追踪的，所以系统能精确知晓哪个组件确实需要被重渲染。你可以理解为每一个组件都已经自动获得了 shouldComponentUpdate，并且没有上述的子树问题限制。

### 监听数据变化的实现原理不同

Vue 通过 getter/setter 以及一些函数的劫持，能精确知道数据变化。React 默认是通过比较引用的方式（diff）进行的，如果不优化可能导致大量不必要的 VDOM 的重新渲染。

这是因为 Vue 和 React 设计理念上的区别，Vue 使用的是可变数据，而 React 更强调数据的不可变，两者没有好坏之分，Vue 更加简单，而 React 构建大型应用的时候更加合适。

#### Vue3.0 里为什么要用 Proxy API 替代 defineProperty API

**defineProperty API 的问题：**

- 检测不到对象属性的添加和删除
- 数组 API 方法无法监听到
- 需要对每个属性进行遍历监听，如果嵌套对象，需要深层监听，造成性能问题

**Proxy API：**

- `Proxy` 直接可以劫持整个对象，并返回一个新对象，我们可以只操作新的对象达到响应式目的
- 可以直接监听数组的变化（push、shift、splice）

### HoC 和 mixins

- Vue 组合不同功能的方式是通过 mixin。
- React 组合不同功能的方式是通过 HoC(高阶组件），高阶组件本质就是高阶函数，React 的组件是一个纯粹的函数，所以高阶函数对 React 来说非常简单。

### 事件

React 组件绑定事件的本质是代理到 document 上。Vue 的事件挂载到真实的 DOM 节点。

react 自己定了一个 event 对象，存放着 onClick 回调们，在用户触发点击点击事件时，挨个检查并执行。

- 自行实现了一套事件捕获到事件冒泡的逻辑, 抹平各个浏览器之前的兼容性问题。
- 事件只在 document 上绑定，并且每种事件只绑定一次，减少内存开销。
- 使用对象池来管理合成事件对象的创建和销毁，可以减少垃圾回收次数，防止内存抖动。

## CDN

CDN 是将源站内容分发至全国所有的节点，从而缩短用户查看对象的延迟，提高用户访问网站的响应速度与网站的可用性的技术。它能够有效解决网络带宽小、用户访问量大、网点分布不均等问题。

其目的是使用户可就近取得所需内容，解决 Internet 网络拥挤的状况，提高用户访问网站的响应速度。

1. 用户向浏览器输入域名，浏览器第一次发现本地没有 dns 缓存，则向网站的 DNS 服务器请求；
2. 网站的 DNS 域名解析器设置了 CNAME,请求指向了 CDN 网络中的智能 DNS 负载均衡系统；
3. 智能 DNS 负载均衡系统解析域名，把对用户响应速度最快的 IP 节点返回给用户；
4. 用户向该 IP 节点（CDN 服务器）发出请求；
5. 由于是第一次访问，CDN 服务器会向原 web 站点请求，并缓存内容；
6. 请求结果发给用户。

## 组件声明周期

### Vue

- beforeCreate
- created
- beforeMoubt
- mounted
- beforeUpdate
- updated
- beforeDestroy
- destroyed

### React

- constructor
- render
- componentDidMount
- shouldComponentUpdate
- componentDidUpdate
- componentWillUnmount

## tree shaking 的原理是什么?

ES6 Module 引入进行静态分析，故而编译的时候正确判断到底加载了那些模块，静态分析程序流，判断那些模块和变量未被使用或者引用，进而删除对应代码。

1. CommonJS 模块输出的是一个值的拷贝，ES6 模块输出的是值的引用。
2. CommonJS 模块是运行时加载，ES6 模块是编译时输出接口。
3. CommonJs 是单个值导出，ES6 Module 可以导出多个
4. CommonJs 是动态语法可以写在判断里，ES6 Module 静态语法只能写在顶层
5. CommonJs 的 this 是当前模块，ES6 Module 的 this 是 undefined

禁止 Babel 将 ES6 编译到 CommonJS。

webpack4 的 mode 集成了多个优化项，在 produciton 模式下默认开启了 Tree Shaking。

sideEffects 可以配置文件导出默认都是无副作用的，在项目中启用后可以减少打包体积。

按需导入。
